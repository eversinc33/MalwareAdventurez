#include <iostream>
#include <windows.h>

//https://processhacker.sourceforge.io/doc/ntpsapi_8h_source.html#l00063
struct PEB_LDR_DATA
{
	ULONG Length;
	BOOLEAN Initialized;
	HANDLE SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID EntryInProgress;
	BOOLEAN ShutdownInProgress;
	HANDLE ShutdownThreadId;
};

//https://processhacker.sourceforge.io/doc/ntpebteb_8h_source.html#l00008
struct PEB
{
	BOOLEAN InheritedAddressSpace;
	BOOLEAN ReadImageFileExecOptions;
	BOOLEAN BeingDebugged;
	union
	{
		BOOLEAN BitField;
		struct
		{
			BOOLEAN ImageUsesLargePages : 1;
			BOOLEAN IsProtectedProcess : 1;
			BOOLEAN IsImageDynamicallyRelocated : 1;
			BOOLEAN SkipPatchingUser32Forwarders : 1;
			BOOLEAN IsPackagedProcess : 1;
			BOOLEAN IsAppContainer : 1;
			BOOLEAN IsProtectedProcessLight : 1;
			BOOLEAN SpareBits : 1;
		};
	};
	HANDLE Mutant;
	PVOID ImageBaseAddress;
	PEB_LDR_DATA* Ldr;
};

struct UNICODE_STRING
{
	USHORT Length;
	USHORT MaximumLength;
	PWCH Buffer;
};

//https://processhacker.sourceforge.io/doc/ntldr_8h_source.html#l00102
struct LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	union
	{
		LIST_ENTRY InInitializationOrderLinks;
		LIST_ENTRY InProgressLinks;
	};
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	//...
};

int main()
{
	// Get the offset of Process Environment Block depending on arch
#ifdef _M_IX86 
	PEB* ProcEnvBlk = (PEB*)__readfsdword(0x30);
#else
	PEB* ProcEnvBlk = (PEB*)__readgsqword(0x60);
#endif

	HMODULE ntdllBase = NULL;

	PEB_LDR_DATA* Ldr = ProcEnvBlk->Ldr;
	LIST_ENTRY* ModuleList = NULL;

	ModuleList = &Ldr->InMemoryOrderModuleList;
	LIST_ENTRY* pStartListEntry = ModuleList->Flink;

	// start from beginning of InMemoryOrderModuleList, walk all entries
	for (LIST_ENTRY* pListEntry = pStartListEntry; pListEntry != ModuleList; pListEntry = pListEntry->Flink) {

		// get current Data Table Entry
		LDR_DATA_TABLE_ENTRY* pEntry = (LDR_DATA_TABLE_ENTRY*)((BYTE*)pListEntry - sizeof(LIST_ENTRY));

		// check if module is found and save its base address
		printf("    Current Module: %ls\n", std::wstring(pEntry->BaseDllName.Buffer, pEntry->BaseDllName.Length / sizeof(WCHAR)).c_str());

		if (strcmp((const char*)pEntry->BaseDllName.Buffer, (const char*)L"ntdll.dll") == 0) {
			ntdllBase = (HMODULE)pEntry->DllBase;
			std::cout << "[*] Found ntdll base address at " << ntdllBase << std::endl;
			break;
		}
	}

	if (ntdllBase == NULL) {
		std::cout << "[!] ntdll base address not found." << std::endl;
		return 1;
	}

	// get .data section of ntdll:
	ULONG_PTR dataSectionAddress = NULL;
	DWORD dataSectionSize;

	// Get pointers to headers in hooked ntdll dll
	PIMAGE_DOS_HEADER ntdllDosHeader = (PIMAGE_DOS_HEADER)ntdllBase;
	PIMAGE_NT_HEADERS ntdllNtHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)ntdllBase + ntdllDosHeader->e_lfanew);

	// iterate over ntdll
	for (WORD i = 0; i < ntdllNtHeader->FileHeader.NumberOfSections; i++) {
		PIMAGE_SECTION_HEADER ntdllSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)IMAGE_FIRST_SECTION(ntdllNtHeader) + ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER * i));

		// if we found the data segment ...
		if (!strcmp((char*)ntdllSectionHeader->Name, (char*)".data")) {
			dataSectionAddress = (ULONG_PTR)(ntdllBase + ntdllSectionHeader[i].VirtualAddress);
			std::cout << "[*] Found .data segment of NTDLL at " << dataSectionAddress << std::endl;
		}
	}

	// TODO: get syscall numbers by identifying syscall prologue
	// TODO: insert syscall numbers in assembly syscall template
	// TODO: cast to syscall function pointer and use that to read ntdll 
}