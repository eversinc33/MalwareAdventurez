#include <iostream>
#include <windows.h>

//https://processhacker.sourceforge.io/doc/ntpsapi_8h_source.html#l00063
struct PEB_LDR_DATA
{
	ULONG Length;
	BOOLEAN Initialized;
	HANDLE SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID EntryInProgress;
	BOOLEAN ShutdownInProgress;
	HANDLE ShutdownThreadId;
};

//https://processhacker.sourceforge.io/doc/ntpebteb_8h_source.html#l00008
struct PEB
{
	BOOLEAN InheritedAddressSpace;
	BOOLEAN ReadImageFileExecOptions;
	BOOLEAN BeingDebugged;
	union
	{
		BOOLEAN BitField;
		struct
		{
			BOOLEAN ImageUsesLargePages : 1;
			BOOLEAN IsProtectedProcess : 1;
			BOOLEAN IsImageDynamicallyRelocated : 1;
			BOOLEAN SkipPatchingUser32Forwarders : 1;
			BOOLEAN IsPackagedProcess : 1;
			BOOLEAN IsAppContainer : 1;
			BOOLEAN IsProtectedProcessLight : 1;
			BOOLEAN SpareBits : 1;
		};
	};
	HANDLE Mutant;
	PVOID ImageBaseAddress;
	PEB_LDR_DATA* Ldr;
};

struct UNICODE_STRING
{
	USHORT Length;
	USHORT MaximumLength;
	PWCH Buffer;
};

//https://processhacker.sourceforge.io/doc/ntldr_8h_source.html#l00102
struct LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	union
	{
		LIST_ENTRY InInitializationOrderLinks;
		LIST_ENTRY InProgressLinks;
	};
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	//...
};

int main()
{
	// Get the offset of Process Environment Block depending on arch
#ifdef _M_IX86 
	PEB* ProcEnvBlk = (PEB*)__readfsdword(0x30);
#else
	PEB* ProcEnvBlk = (PEB*)__readgsqword(0x60);
#endif

	ULONG_PTR ntdllBase = NULL;

	PEB_LDR_DATA* Ldr = ProcEnvBlk->Ldr;
	LIST_ENTRY* ModuleList = NULL;

	ModuleList = &Ldr->InMemoryOrderModuleList;
	LIST_ENTRY* pStartListEntry = ModuleList->Flink;

	// start from beginning of InMemoryOrderModuleList, walk all entries
	for (LIST_ENTRY* pListEntry = pStartListEntry; pListEntry != ModuleList; pListEntry = pListEntry->Flink) {

		// get current Data Table Entry
		LDR_DATA_TABLE_ENTRY* pEntry = (LDR_DATA_TABLE_ENTRY*)((BYTE*)pListEntry - sizeof(LIST_ENTRY));

		// check if module is found and save its base address
		printf("    Current Module: %ls\n", std::wstring(pEntry->BaseDllName.Buffer, pEntry->BaseDllName.Length / sizeof(WCHAR)).c_str());

		if (strcmp((const char*)pEntry->BaseDllName.Buffer, (const char*)L"ntdll.dll") == 0) {
			ntdllBase = (ULONG_PTR)pEntry->DllBase;
			std::cout << "[*] Found ntdll base address at " << std::hex << ntdllBase << std::endl;
			break;
		}
	}

	if (ntdllBase == NULL) {
		std::cout << "[!] ntdll base address not found." << std::endl;
		return 1;
	}

	// get .data section of ntdll:
	ULONG_PTR dataSectionAddress = NULL;
	DWORD dataSectionSize = 0;

	// Get pointers to headers in ntdll dll
	PIMAGE_DOS_HEADER ntdllDosHeader = (PIMAGE_DOS_HEADER)ntdllBase;
	PIMAGE_NT_HEADERS ntdllNtHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)ntdllBase + ntdllDosHeader->e_lfanew);

	// iterate over ntdll
	for (WORD i = 0; i < ntdllNtHeader->FileHeader.NumberOfSections; i++) {
		PIMAGE_SECTION_HEADER ntdllSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)IMAGE_FIRST_SECTION(ntdllNtHeader) + ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER * i));

		// std::cout << (char*)ntdllSectionHeader->Name << std::endl;
		// 
		// if we found the data segment, get its address and size
		if (!strcmp((char*)ntdllSectionHeader->Name, (char*)".data")) {
			dataSectionAddress = ntdllBase + ntdllSectionHeader[i].VirtualAddress;
			dataSectionSize = ntdllSectionHeader[i].Misc.VirtualSize;
			std::cout << "[*] Found .data segment of NTDLL at " << std::hex << dataSectionAddress << " with size " << dataSectionSize << std::endl;
			break;
		}
	}

	if (dataSectionAddress == NULL) {
		std::cout << "[!] data section not found." << std::endl;
		return 1;
	}

	// go over data segment and look for syscall signatures
	for (UINT offset = 0; offset < dataSectionSize; offset++) {
		// b8d18b4c == opcode for syscall prologue 
		// 4c:8bd1 mov r10,rcx 
		// b8 XXX  mov eax,XXX
		if (*(DWORD*)(dataSectionAddress + offset) == 0xb8d18b4c or *(DWORD*)(dataSectionAddress + offset) == 0x4c8bd1b8) {
			std::cout << "Found syscall at " << std::hex << dataSectionAddress + offset << std::endl;
		}
	}

	std::cout << "[*] Done";

	// TODO: insert syscall numbers in assembly syscall template
	// TODO: cast to syscall function pointer and use that to read ntdll 
}