#include <iostream>
#include <windows.h>

typedef struct _IO_STATUS_BLOCK {
	union {
		NTSTATUS Status;
		PVOID Pointer;
	};
	ULONG_PTR Information;
} IO_STATUS_BLOCK, * PIO_STATUS_BLOCK;

typedef struct _UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR  Buffer;
} UNICODE_STRING, * PUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES
{
	ULONG Length;
	HANDLE RootDirectory;
	PUNICODE_STRING ObjectName;
	ULONG Attributes;
	PVOID SecurityDescriptor;        
	PVOID SecurityQualityOfService;  

} OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;

// Syscalls:
typedef NTSYSAPI NTSTATUS(NTAPI* MyNT_OPEN_FILE)(
	OUT PHANDLE FileHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN ULONG ShareAccess,
	IN ULONG OpenOptions
);

typedef NTSTATUS(NTAPI* MyNT_CREATE_SECTION)
(_Out_ PHANDLE SectionHandle, _In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_opt_ PLARGE_INTEGER MaximumSize, _In_ ULONG SectionPageProtection,
	_In_ ULONG AllocationAttributes, _In_opt_ HANDLE FileHandle);

typedef NTSTATUS(NTAPI* MyNT_MAP_VIEW_OF_SECTION)
(_In_ HANDLE SectionHandle, _In_ HANDLE ProcessHandle,
	_Inout_ PVOID* BaseAddress, _In_ ULONG_PTR ZeroBits, _In_ SIZE_T CommitSize,
	_Inout_opt_ PLARGE_INTEGER SectionOffset, _Inout_ PSIZE_T ViewSize,
	_In_ DWORD InheritDisposition, _In_ ULONG AllocationType,
	_In_ ULONG Win32Protect);

MyNT_OPEN_FILE NtOpenFile = NULL;
MyNT_CREATE_SECTION NtCreateSection = NULL;
MyNT_MAP_VIEW_OF_SECTION NtMapViewOfSection = NULL;

//https://processhacker.sourceforge.io/doc/ntpsapi_8h_source.html#l00063
struct PEB_LDR_DATA
{
	ULONG Length;
	BOOLEAN Initialized;
	HANDLE SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID EntryInProgress;
	BOOLEAN ShutdownInProgress;
	HANDLE ShutdownThreadId;
};

//https://processhacker.sourceforge.io/doc/ntpebteb_8h_source.html#l00008
struct PEB
{
	BOOLEAN InheritedAddressSpace;
	BOOLEAN ReadImageFileExecOptions;
	BOOLEAN BeingDebugged;
	union
	{
		BOOLEAN BitField;
		struct
		{
			BOOLEAN ImageUsesLargePages : 1;
			BOOLEAN IsProtectedProcess : 1;
			BOOLEAN IsImageDynamicallyRelocated : 1;
			BOOLEAN SkipPatchingUser32Forwarders : 1;
			BOOLEAN IsPackagedProcess : 1;
			BOOLEAN IsAppContainer : 1;
			BOOLEAN IsProtectedProcessLight : 1;
			BOOLEAN SpareBits : 1;
		};
	};
	HANDLE Mutant;
	PVOID ImageBaseAddress;
	PEB_LDR_DATA* Ldr;
};

struct UNICODE_STRING
{
	USHORT Length;
	USHORT MaximumLength;
	PWCH Buffer;
};

//https://processhacker.sourceforge.io/doc/ntldr_8h_source.html#l00102
struct LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	union
	{
		LIST_ENTRY InInitializationOrderLinks;
		LIST_ENTRY InProgressLinks;
	};
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	//...
};

// Syscall stub
ULONG_PTR BuildSyscall(ULONG_PTR StubRegion, DWORD dwSyscallNo)
{
	BYTE SyscallStub[] =
	{
		0x4c, 0x8b, 0xd1,				// mov     r10,rcx
		0xb8, 0x00, 0x00, 0x00, 0x00,	// mov     eax,xxx
		0x0f, 0x05,						// syscall
		0xc3							// ret
};

	memcpy((PBYTE)StubRegion, SyscallStub, sizeof(SyscallStub));
	*(DWORD*)(StubRegion + 4) = dwSyscallNo;

	return StubRegion;
}

int main()
{
	// Get the offset of Process Environment Block depending on arch
#ifdef _M_IX86 
	PEB* ProcEnvBlk = (PEB*)__readfsdword(0x30);
#else
	PEB* ProcEnvBlk = (PEB*)__readgsqword(0x60);
#endif

	ULONG_PTR ntdllBase = NULL;

	PEB_LDR_DATA* Ldr = ProcEnvBlk->Ldr;
	LIST_ENTRY* ModuleList = &Ldr->InLoadOrderModuleList; // <- inLoadOrder!
	LDR_DATA_TABLE_ENTRY* ldrEntry = (LDR_DATA_TABLE_ENTRY*)Ldr->InLoadOrderModuleList.Flink;

	// start from beginning of InLoadOrderModuleList, walk all entries
	for (ldrEntry; ldrEntry->DllBase != NULL;
		ldrEntry = (LDR_DATA_TABLE_ENTRY*)ldrEntry->InLoadOrderLinks.Flink) {

		// check if module is found and save its base address
		printf("    Current Module: %ls\n", std::wstring(ldrEntry->BaseDllName.Buffer, ldrEntry->BaseDllName.Length / sizeof(WCHAR)).c_str());
		if (_wcsnicmp(ldrEntry->BaseDllName.Buffer, L"ntdll.dll", 9) == 0) {
			ntdllBase = (ULONG_PTR)ldrEntry->DllBase;
			std::cout << "[*] Found ntdll base address at " << std::hex << ntdllBase << std::endl;
			break;
		}
	}

	if (ntdllBase == NULL) {
		std::cout << "[!] ntdll base address not found." << std::endl;
		return 1;
	}

	// get .data section of ntdll:

	// Get pointers to headers in ntdll dll
	PIMAGE_NT_HEADERS ntdllNtHeader = (PIMAGE_NT_HEADERS)(ntdllBase + ((PIMAGE_DOS_HEADER)ntdllBase)->e_lfanew);
	PIMAGE_SECTION_HEADER ntdllSectionHeader = (PIMAGE_SECTION_HEADER)((ULONG_PTR)&ntdllNtHeader->OptionalHeader + ntdllNtHeader->FileHeader.SizeOfOptionalHeader);

	ULONG_PTR dataSectionAddress = NULL;
	DWORD dataSectionSize;

	// iterate over ntdll
	for (WORD i = 0; i < ntdllNtHeader->FileHeader.NumberOfSections; i++)
	{
		// if we found the data segment, get its address and size
		if (!strcmp((char*)ntdllSectionHeader[i].Name, ".data")) {
			dataSectionAddress = ntdllBase + ntdllSectionHeader[i].VirtualAddress;
			dataSectionSize = ntdllSectionHeader[i].Misc.VirtualSize;
			std::cout << "[*] Found .data segment of NTDLL at " << std::hex << dataSectionAddress << " with size " << dataSectionSize << std::endl;
			break;
		}
	}

	if (dataSectionAddress == NULL) {
		std::cout << "[!] data section not found." << std::endl;
		return 1;
	}

	DWORD syscallNumber_NtOpenFile = 0;
	DWORD syscallNumber_NtCreateSection = 0;
	DWORD syscallNumber_NtMapViewOfSection = 0;

	// go over data segment and look for syscall signatures
	for (UINT offset = 0; offset < dataSectionSize; offset++) {
		// b8d18b4c == opcode for syscall prologue 
		// 4c:8bd1 mov r10,rcx 
		// b8 XXX  mov eax,XXX
		if (*(DWORD*)(dataSectionAddress + offset) == 0xb8d18b4c &&
			*(DWORD*)(dataSectionAddress + offset + 16) == 0xb8d18b4c &&
			*(DWORD*)(dataSectionAddress + offset + 32) == 0xb8d18b4c &&
			*(DWORD*)(dataSectionAddress + offset + 48) == 0xb8d18b4c &&
			*(DWORD*)(dataSectionAddress + offset + 64) == 0xb8d18b4c)
		{
			std::cout << "Found syscalls at " << std::hex << dataSectionAddress + offset << std::endl;

			// parse syscall numbers
			syscallNumber_NtOpenFile = *(DWORD*)(dataSectionAddress + offset + 4); 
			syscallNumber_NtCreateSection = *(DWORD*)(dataSectionAddress + offset + 16 + 4);
			syscallNumber_NtMapViewOfSection = *(DWORD*)(dataSectionAddress + offset + 64 + 4);
			break;
		}
	}

	std::cout << "[*] Done";

	// reserve memory for syscalls
	SIZE_T maxSyscallStubSize = 64;
	ULONG_PTR SyscallRegion = (ULONG_PTR)VirtualAlloc(NULL, 3 * maxSyscallStubSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	
	// create syscalls by inserting parsed syscall numbers into syscall stub
	NtOpenFile = (MyNT_OPEN_FILE)BuildSyscall(SyscallRegion, syscallNumber_NtOpenFile);
	NtCreateSection = (MyNT_CREATE_SECTION)BuildSyscall(SyscallRegion + maxSyscallStubSize, syscallNumber_NtCreateSection);
	NtMapViewOfSection = (MyNT_MAP_VIEW_OF_SECTION)BuildSyscall(SyscallRegion + (2 * maxSyscallStubSize), syscallNumber_NtMapViewOfSection);

	// TODO: we got syscalls, now read a new copy of ntdll and unhook our ntdll	
}