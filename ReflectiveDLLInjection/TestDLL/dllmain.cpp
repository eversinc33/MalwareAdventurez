// dllmain.cpp : Defines the entry point for the DLL application.
#include "pch.h"
#include <windows.h>
#include <intrin.h>

#pragma intrinsic(_ReturnAddress)

typedef HMODULE(WINAPI* LOADLIBRARYA)(LPCSTR);
typedef FARPROC(WINAPI* GETPROCADDRESS)(HMODULE, LPCSTR);
typedef LPVOID(WINAPI* VIRTUALALLOC)(LPVOID, SIZE_T, DWORD, DWORD);
typedef DWORD(NTAPI* NTFLUSHINSTRUCTIONCACHE)(HANDLE, PVOID, ULONG);

#define DEREF( name )*(UINT_PTR *)(name)

//https://processhacker.sourceforge.io/doc/ntpsapi_8h_source.html#l00063
struct PEB_LDR_DATA
{
	ULONG Length;
	BOOLEAN Initialized;
	HANDLE SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID EntryInProgress;
	BOOLEAN ShutdownInProgress;
	HANDLE ShutdownThreadId;
};
//https://processhacker.sourceforge.io/doc/ntpebteb_8h_source.html#l00008
struct PEB
{
	BOOLEAN InheritedAddressSpace;
	BOOLEAN ReadImageFileExecOptions;
	BOOLEAN BeingDebugged;
	union
	{
		BOOLEAN BitField;
		struct
		{
			BOOLEAN ImageUsesLargePages : 1;
			BOOLEAN IsProtectedProcess : 1;
			BOOLEAN IsImageDynamicallyRelocated : 1;
			BOOLEAN SkipPatchingUser32Forwarders : 1;
			BOOLEAN IsPackagedProcess : 1;
			BOOLEAN IsAppContainer : 1;
			BOOLEAN IsProtectedProcessLight : 1;
			BOOLEAN SpareBits : 1;
		};
	};
	HANDLE Mutant;
	PVOID ImageBaseAddress;
	PEB_LDR_DATA* Ldr;
	//...
};

struct UNICODE_STRING
{
	USHORT Length;
	USHORT MaximumLength;
	PWCH Buffer;
};

//https://processhacker.sourceforge.io/doc/ntldr_8h_source.html#l00102
struct LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	union
	{
		LIST_ENTRY InInitializationOrderLinks;
		LIST_ENTRY InProgressLinks;
	};
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	//...
};

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        MessageBox(NULL, L"DLL loaded!", L"YEE", MB_OK);
        return TRUE;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

// We have to make sure this isnt inlined so that we actually get a valid address
__declspec(noinline) ULONG_PTR getCallerAddress(VOID) 
{ 
    return (ULONG_PTR)_ReturnAddress(); 
}

HMODULE WINAPI hlpGetModuleHandle(LPCWSTR sModuleName) 
{
	// get the offset of Process Environment Block
#ifdef _M_IX86 
	PEB* ProcEnvBlk = (PEB*)__readfsdword(0x30);
#else
	PEB* ProcEnvBlk = (PEB*)__readgsqword(0x60);
#endif

	// return base address of a calling module
	if (sModuleName == NULL)
		return (HMODULE)(ProcEnvBlk->ImageBaseAddress);

	PEB_LDR_DATA* Ldr = ProcEnvBlk->Ldr;
	LIST_ENTRY* ModuleList = NULL;

	ModuleList = &Ldr->InMemoryOrderModuleList;
	LIST_ENTRY* pStartListEntry = ModuleList->Flink;

	for (LIST_ENTRY* pListEntry = pStartListEntry;  		// start from beginning of InMemoryOrderModuleList
		pListEntry != ModuleList;	    	// walk all list entries
		pListEntry = pListEntry->Flink) {

		// get current Data Table Entry
		LDR_DATA_TABLE_ENTRY* pEntry = (LDR_DATA_TABLE_ENTRY*)((BYTE*)pListEntry - sizeof(LIST_ENTRY));

		// check if module is found and return its base address
		if (strcmp((const char*)pEntry->BaseDllName.Buffer, (const char*)sModuleName) == 0)
			return (HMODULE)pEntry->DllBase;
	}

	// otherwise:
	return NULL;
}

FARPROC WINAPI hlpGetProcAddress(HMODULE hMod, char* sProcName) 
{
	char* pBaseAddr = (char*)hMod;

	// get pointers to main headers/structures
	IMAGE_DOS_HEADER* pDosHdr = (IMAGE_DOS_HEADER*)pBaseAddr;
	IMAGE_NT_HEADERS* pNTHdr = (IMAGE_NT_HEADERS*)(pBaseAddr + pDosHdr->e_lfanew);
	IMAGE_OPTIONAL_HEADER* pOptionalHdr = &pNTHdr->OptionalHeader;
	IMAGE_DATA_DIRECTORY* pExportDataDir = (IMAGE_DATA_DIRECTORY*)(&pOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]);
	IMAGE_EXPORT_DIRECTORY* pExportDirAddr = (IMAGE_EXPORT_DIRECTORY*)(pBaseAddr + pExportDataDir->VirtualAddress);

	// resolve addresses to Export Address Table, table of function names and "table of ordinals"
	DWORD* pEAT = (DWORD*)(pBaseAddr + pExportDirAddr->AddressOfFunctions);
	DWORD* pFuncNameTbl = (DWORD*)(pBaseAddr + pExportDirAddr->AddressOfNames);
	WORD* pHintsTbl = (WORD*)(pBaseAddr + pExportDirAddr->AddressOfNameOrdinals);

	// function address we're looking for
	void* pProcAddr = NULL;

	// resolve function by ordinal
	if (((DWORD_PTR)sProcName >> 16) == 0) {
		WORD ordinal = (WORD)sProcName & 0xFFFF;	// convert to WORD
		DWORD Base = pExportDirAddr->Base;			// first ordinal number

		// check if ordinal is not out of scope
		if (ordinal < Base || ordinal >= Base + pExportDirAddr->NumberOfFunctions)
			return NULL;

		// get the function virtual address = RVA + BaseAddr
		pProcAddr = (FARPROC)(pBaseAddr + (DWORD_PTR)pEAT[ordinal - Base]);
	}
	// resolve function by name
	else {
		// parse through table of function names
		for (DWORD i = 0; i < pExportDirAddr->NumberOfNames; i++) {
			char* sTmpFuncName = (char*)pBaseAddr + (DWORD_PTR)pFuncNameTbl[i];

			if (strcmp(sProcName, sTmpFuncName) == 0) {
				// found, get the function virtual address = RVA + BaseAddr
				pProcAddr = (FARPROC)(pBaseAddr + (DWORD_PTR)pEAT[pHintsTbl[i]]);
				break;
			}
		}
	}

	// forwarded functions are not resolved
	return (FARPROC)pProcAddr;
}

__declspec(dllexport) ULONG_PTR WINAPI ReflectiveLoader(VOID)
{
    // Step 1: Get own base address

    // we start with our caller address and go back until we found the MZ header
    ULONG_PTR currAddr = getCallerAddress();

    while (TRUE)
    {
        // if MZ header found
        if (((PIMAGE_DOS_HEADER)currAddr)->e_magic == IMAGE_DOS_SIGNATURE)
        {
            // Note Stephen Fewer:
            // > some x64 dll's can trigger a bogus signature (IMAGE_DOS_SIGNATURE == 'POP r10'),
            // > we sanity check the e_lfanew with an upper threshold value of 1024 to avoid problems.
            ULONG_PTR peHeaderOffset = ((PIMAGE_DOS_HEADER)currAddr)->e_lfanew;
            if (peHeaderOffset >= sizeof(IMAGE_DOS_HEADER) && peHeaderOffset < 1024)
            {
                // break if we have found a valid PE header too
                if (((PIMAGE_NT_HEADERS)(currAddr + peHeaderOffset))->Signature == IMAGE_NT_SIGNATURE)
                    break;
            }
        }
        currAddr--;
    }

	ULONG_PTR moduleBaseAddr = currAddr;

    // Step 2: get functions we need for loading
	HMODULE kernel32dll = hlpGetModuleHandle(L"KERNEL32.DLL");
	VIRTUALALLOC pVirtualAlloc = (VIRTUALALLOC)hlpGetProcAddress(kernel32dll, (char*)"VirtualALloc");
	LOADLIBRARYA pLoadLibraryA = (LOADLIBRARYA)hlpGetProcAddress(kernel32dll, (char*)"LoadLibraryA");
	GETPROCADDRESS pGetProcAddress = (GETPROCADDRESS)hlpGetProcAddress(kernel32dll, (char*)"GetProcAddress");

	// Step 3: Copy our image to a new location
	
	// Get headers
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)moduleBaseAddr;
	PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)(moduleBaseAddr + dosHeader->e_lfanew);

	// get image size from nt header
	DWORD imageSize = ((PIMAGE_NT_HEADERS)ntHeader)->OptionalHeader.SizeOfImage;

	// allocate all the memory for the DLL to be loaded into. we can load at any address because we will  
	// relocate the image. Also zeros all memory and marks it as READ, WRITE and EXECUTE to avoid any problems.
	ULONG_PTR newBaseAddress = (ULONG_PTR)pVirtualAlloc(NULL, imageSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	// we must now copy over the headers
	DWORD sizeOfHeaders = ntHeader->OptionalHeader.SizeOfHeaders;
	ULONG_PTR firstModuleBaseAddress = moduleBaseAddr;
	ULONG_PTR newModuleBaseAddress = newBaseAddress;
	for (int i=0; i<sizeOfHeaders; ++i)
	{
		*(BYTE*)newModuleBaseAddress++ = *(BYTE*)firstModuleBaseAddress++;
	}

	// Step 4: load in all of our sections...

	DWORD virtualAddressOfFirstSection = ((ULONG_PTR) & ntHeader->OptionalHeader + ntHeader->FileHeader.SizeOfOptionalHeader;
	DWORD currSectionAddr = virtualAddressOfFirstSection;

	// itterate through all sections, loading them into memory.
	DWORD numberOfSections = ntHeader->FileHeader.NumberOfSections;
	for (int i=0; i<numberOfSections; ++i)
	{
		PIMAGE_SECTION_HEADER currSectionHeader = (PIMAGE_SECTION_HEADER)(currSectionAddr);

		DWORD vaForSectionOfNewModule = newModuleBaseAddress + currSectionHeader->VirtualAddress;
		DWORD vaForSectionDataOfOldModule = firstModuleBaseAddress + currSectionHeader->PointerToRawData;

		// copy the section over
		for (int i = 0; i < currSectionHeader->SizeOfRawData; ++i)
		{
			*(BYTE*)vaForSectionOfNewModule++ = *(BYTE*)vaForSectionDataOfOldModule++;
		}

		// get the VA of the next section
		currSectionAddr += sizeof(IMAGE_SECTION_HEADER);
	}

	// Step 5: process our images import table...
	
	// uiValueB = the address of the import directory
	DWORD importDirAddr = (ULONG_PTR) & ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];

	// we assume their is an import table to process
	// uiValueC is the first entry in the import table
	PIMAGE_IMPORT_DESCRIPTOR currImportTableEntry = (PIMAGE_IMPORT_DESCRIPTOR)(newModuleBaseAddress + ((PIMAGE_DATA_DIRECTORY)importDirAddr)->VirtualAddress);

	// itterate through all imports
	while (currImportTableEntry->Name)
	{
		// use LoadLibraryA to load the imported module into memory
		ULONG_PTR loadedLibraryModuleHandle = (ULONG_PTR)pLoadLibraryA((LPCSTR)(newModuleBaseAddress + currImportTableEntry->Name));

		// uiValueD = VA of the OriginalFirstThunk
		DWORD vaOfFirstThunk = newModuleBaseAddress + currImportTableEntry->OriginalFirstThunk;

		// uiValueA = VA of the IAT (via first thunk not origionalfirstthunk)
		DWORD vaOfIAT = newModuleBaseAddress + currImportTableEntry->FirstThunk;

		// itterate through all imported functions, importing by ordinal if no name present
		while (DEREF(vaOfIAT))
		{
			// sanity check uiValueD as some compilers only import by FirstThunk
			if (vaOfFirstThunk && ((PIMAGE_THUNK_DATA)vaOfFirstThunk)->u1.Ordinal & IMAGE_ORDINAL_FLAG)
			{
				// get the VA of the modules NT Header
				uiExportDir = uiLibraryAddress + dosHeader->e_lfanew;

				// uiNameArray = the address of the modules export directory entry
				uiNameArray = (ULONG_PTR) & ((PIMAGE_NT_HEADERS)uiExportDir)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];

				// get the VA of the export directory
				uiExportDir = (uiLibraryAddress + ((PIMAGE_DATA_DIRECTORY)uiNameArray)->VirtualAddress);

				// get the VA for the array of addresses
				uiAddressArray = (uiLibraryAddress + ((PIMAGE_EXPORT_DIRECTORY)uiExportDir)->AddressOfFunctions);

				// use the import ordinal (- export ordinal base) as an index into the array of addresses
				uiAddressArray += ((IMAGE_ORDINAL(((PIMAGE_THUNK_DATA)uiValueD)->u1.Ordinal) - ((PIMAGE_EXPORT_DIRECTORY)uiExportDir)->Base) * sizeof(DWORD));

				// patch in the address for this imported function
				DEREF(uiValueA) = (uiLibraryAddress + DEREF_32(uiAddressArray));
			}
			else
			{
				// get the VA of this functions import by name struct
				uiValueB = (uiBaseAddress + DEREF(uiValueA));

				// use GetProcAddress and patch in the address for this imported function
				DEREF(uiValueA) = (ULONG_PTR)pGetProcAddress((HMODULE)uiLibraryAddress, (LPCSTR)((PIMAGE_IMPORT_BY_NAME)uiValueB)->Name);
			}
			// get the next imported function
			uiValueA += sizeof(ULONG_PTR);
			if (uiValueD)
				uiValueD += sizeof(ULONG_PTR);
		}

		// get the next import
		currImportTableEntry += sizeof(IMAGE_IMPORT_DESCRIPTOR);
	}

    return 0;
}


