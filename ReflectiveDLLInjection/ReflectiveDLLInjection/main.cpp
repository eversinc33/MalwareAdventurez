#include "main.h"
#include <windows.h>
#include <iostream>

// Convert Virtual Address to File Offset 
// The RVA is the relative - virtual address, that is, the distance from the preferred base address.
// The preferred base address is stated in the PE header, and is the(preferred) virtual address of the start of the image in memory 
// for when the executable be loaded in memory.
// Many references inside a PE are given as RVAs. In such cases, you need to check in all the section headers (or have some sort of map) 
// to get the offset in the PE file of the reference.
DWORD Rva2Offset(DWORD rva, PIMAGE_SECTION_HEADER psh, PIMAGE_NT_HEADERS pnt)
{
	size_t i = 0;
	if (rva == 0)
	{
		return (rva);
	}
	for (i = 0; i < pnt->FileHeader.NumberOfSections; i++)
	{
		if (rva >= psh->VirtualAddress && rva < psh->VirtualAddress + psh->Misc.VirtualSize)
		{
			break;
		}
		psh++;
	}
	return (rva - psh->VirtualAddress + psh->PointerToRawData);
}

REFLECTIVELOADER FindReflectiveLoader(PBYTE pBaseAddr, char* sProcName)
{
	PIMAGE_DOS_HEADER pImageDosHeader = (PIMAGE_DOS_HEADER)pBaseAddr;
	PIMAGE_NT_HEADERS pImageNtHeaders = (PIMAGE_NT_HEADERS)((PBYTE)pBaseAddr + pImageDosHeader->e_lfanew);
	PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)((PBYTE)pBaseAddr + pImageDosHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS));
	// In hellsgate this Rva2Offset would not be needed, as ntdll is already loaded in memory, but here we have a raw pe file!
	DWORD imageEatOffset = Rva2Offset(pImageNtHeaders->OptionalHeader.DataDirectory[0].VirtualAddress, pSectionHeader, pImageNtHeaders);
	PIMAGE_EXPORT_DIRECTORY pImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)pBaseAddr + imageEatOffset);

	DWORD* addressOfFunctions = (DWORD*)((PBYTE)pBaseAddr + Rva2Offset(pImageExportDirectory->AddressOfFunctions, pSectionHeader, pImageNtHeaders));
	DWORD* tableOfFunctionNames = (DWORD*)(pBaseAddr + Rva2Offset(pImageExportDirectory->AddressOfNames, pSectionHeader, pImageNtHeaders));
	WORD* tableOfOrdinals = (WORD*)(pBaseAddr + Rva2Offset(pImageExportDirectory->AddressOfNameOrdinals, pSectionHeader, pImageNtHeaders));

	// resolve function by name by going through table of function names
	for (DWORD i = 0; i < pImageExportDirectory->NumberOfNames; i++)
	{
		char* sTmpFuncName = (char*)((PBYTE)pBaseAddr + Rva2Offset((DWORD_PTR)tableOfFunctionNames[i], pSectionHeader, pImageNtHeaders));
		std::cout << sTmpFuncName << std::endl;

		if ((strstr(sTmpFuncName, sProcName) != NULL))
		{
			// found, get the function virtual address -> RVA + BaseAddr
			return (REFLECTIVELOADER)(pBaseAddr + Rva2Offset((DWORD_PTR)addressOfFunctions[tableOfOrdinals[i]], pSectionHeader, pImageNtHeaders));
		}
	}
	printf("[!] No reflective loader found!\n");
	exit(1);
}

int main(int argc, char* argv[])
{
	DWORD targetProc = GetCurrentProcessId();
	const char* dllFile = "C:\\Users\\jdoe\\source\\repos\\ReflectiveDLLInjection\\x64\\Debug\\TestDLL.dll";
	
	printf("[*] Opening handle to DLL file\n");
	HANDLE hFile = CreateFileA(dllFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		printf("Failed to open the DLL file\n");
		return 1;
	}

	printf("[*] Getting DLL file size\n");
	DWORD fileSize = GetFileSize(hFile, NULL);
	if (fileSize == INVALID_FILE_SIZE || fileSize == 0)
	{
		printf("Failed to get the DLL file size\n");
		return 1;
	}

	printf("[*] Allocating memory for DLL\n");
	LPVOID buf = HeapAlloc(GetProcessHeap(), 0, fileSize);
	if (!buf)
	{
		printf("Failed to allocate memory for dll\n");
		return 1;

	}

	printf("[*] Reading file into buffer\n");
	DWORD bytesRead;
	if (!ReadFile(hFile, buf, fileSize, &bytesRead, NULL))
	{
		printf("Error reading DLL\n");
		return 1;
	}

	// TODO: get sedebugprivilege if target proc is a system proc

	printf("[*] Opening handle to target process (own proc in this case)\n");
	HANDLE proc = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, FALSE, targetProc);
	if (!proc)
	{
		printf("Error opening handle to target process\n");
		return 1;
	}

	printf("[*] Locating the reflective loader function by parsing the EAT\n");
	REFLECTIVELOADER reflectiveLoaderFunction = FindReflectiveLoader((PBYTE)buf, (char*)"ReflectiveLoader");
	if (!reflectiveLoaderFunction)
	{
		printf("Error finding ReflectiveLoader function\n");
		return 1;
	}
	std::cout << "[*] Found ReflectiveLoader function at 0x" << std::hex << reflectiveLoaderFunction << std::endl;

	printf("[*] Executing reflective loader!\n");
	DWORD oldProtect;
	if (VirtualProtect(buf, fileSize, PAGE_EXECUTE_READWRITE, &oldProtect))
	{
		DLLMAIN dllMain = (DLLMAIN)reflectiveLoaderFunction();
		/*
		if (dllMain != NULL)
		{
			dllMain(NULL, DLL_PROCESS_ATTACH, NULL);
		}

		VirtualProtect(lpBuffer, dwLength, oldProtect, NULL);
		*/
	}
}