#pragma once

#include <Windows.h>
#include <vector>
#include <iostream>
#include <algorithm>

struct SYSCALL_ENTRY {
	std::string syscallName;
	int syscallNumber;
	char* syscallInstructionAddress;
};

// syscall sorting table
std::vector<SYSCALL_ENTRY> syscallTable;

typedef _Return_type_success_(return >= 0) LONG NTSTATUS;

extern "C" void PrepareSyscall(DWORD dwSycallNr, PVOID dw64Gate);

// NtProtectVirtualMemory
extern "C" NTSTATUS __stdcall DoSyscallProtectVirtual(_In_ HANDLE ProcessHandle, _In_ PVOID * BaseAddress, _In_ SIZE_T * NumberOfBytesToProtect, _In_ ULONG NewAccessProtection, _Out_ PULONG OldAccessProtection);

// NtAllocateVIrtualMemory
extern "C" NTSTATUS __stdcall DoSyscallAllocVirtual(
	HANDLE    ProcessHandle,
	PVOID * BaseAddress,
	ULONG_PTR ZeroBits,
	PSIZE_T   RegionSize,
	ULONG     AllocationType,
	ULONG     Protect
);

SYSCALL_ENTRY getSyscallEntry(std::string name)
{
	for (auto entry : syscallTable)
	{
		if (entry.syscallName == name)
			return entry;
	}
}

void populateSyscallMap(HMODULE ntdllBaseAddr)
{
	char* pBaseAddr = (char*)ntdllBaseAddr;

	// get pointers to main headers/structures
	IMAGE_DOS_HEADER* pDosHdr = (IMAGE_DOS_HEADER*)pBaseAddr;
	IMAGE_NT_HEADERS* pNTHdr = (IMAGE_NT_HEADERS*)(pBaseAddr + pDosHdr->e_lfanew);
	IMAGE_OPTIONAL_HEADER* pOptionalHdr = &pNTHdr->OptionalHeader;
	IMAGE_DATA_DIRECTORY* pExportDataDir = (IMAGE_DATA_DIRECTORY*)(&pOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]);
	IMAGE_EXPORT_DIRECTORY* pExportDirAddr = (IMAGE_EXPORT_DIRECTORY*)(pBaseAddr + pExportDataDir->VirtualAddress);

	// resolve addresses to Export Address Table, table of function names and "table of ordinals"
	DWORD* pEAT = (DWORD*)(pBaseAddr + pExportDirAddr->AddressOfFunctions);
	DWORD* pFuncNameTbl = (DWORD*)(pBaseAddr + pExportDirAddr->AddressOfNames);
	WORD* pHintsTbl = (WORD*)(pBaseAddr + pExportDirAddr->AddressOfNameOrdinals);

	int currentSyscallNumber = 0;

	// parse through table of function names
	for (DWORD i = 0; i < pExportDirAddr->NumberOfNames; i++) {
		char* sTmpFuncName = (char*)pBaseAddr + (DWORD_PTR)pFuncNameTbl[i];

		if (sTmpFuncName[0] == 'Z' && sTmpFuncName[1] == 'w') // ||
			// sTmpFuncName[0] == 'N' && sTmpFuncName[1] == 't')
		{
			// found a syscall
			char* syscallInstrunctionAddr = 0;

			char* pProcAddr = pBaseAddr + (DWORD_PTR)pEAT[pHintsTbl[i]];

			int offset = 0;
			while(TRUE) {
				// 050f0375 == opcode for syscall 
				if (*(DWORD*)(pProcAddr + offset) == 0x050f0375)
				{
					syscallInstrunctionAddr = pProcAddr + offset;
					break;
				}
				offset++;
			} 

			SYSCALL_ENTRY currSyscall = {
				sTmpFuncName, 0, syscallInstrunctionAddr
			};

			syscallTable.push_back(currSyscall);
			
			currentSyscallNumber++;
		}
	}

	// sort by address
	std::sort(syscallTable.begin(), syscallTable.end(), 
		[](SYSCALL_ENTRY& a, SYSCALL_ENTRY& b) { 
			return a.syscallInstructionAddress < b.syscallInstructionAddress; 
		}
	);

	// assign numbers by order and replace Zw with Nt
	for (int i=0; i < syscallTable.size(); i++)
	{
		syscallTable[i].syscallNumber = i;
		syscallTable[i].syscallName.replace(0, 2, "Nt");
	}
}
